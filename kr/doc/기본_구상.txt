기본 구조.

1. 가격정보를 받아서 배포하는 모듈
2. 가격정보를 토대로 확률을 계산하는 모듈. 
	(금리 + 알파의 수익을 지향한다는 의미에서 흔히들 알파 모듈이라고 함.)
3. 위험관리 및 자금관리 모듈
4. 거래 주문을 증권사에 보내는 모듈

각 모듈은 goroutine을 이용해서 동시에 실행됨.

즉, 가격정보를 받아서 확률을 계산하고, 위험관리 룰에 위배되는 지 확인한 후 주문을 내는 동작이
순차적으로 진행되는 것이 아니라, 각 모듈이 동시에 독자적으로 실행됨.
순차적으로 수행된다면 알파 모듈이 계산을 수행하는 동안에 들어오는 새로운 가격정보는 못 받게 될 수 있음.
그러나, 알파 모듈과 가격정보 수집 모듈이 독자적으로 동시에 작동하면 그런 문제가 없음.

예전에는 이러한 동시처리를 스레드나 이벤트를 이용해서 구현하면서 온갖 복잡한 문제가 생겼었지만,
Go언어는 자체적으로 간편하게 동시처리를 수행하는 goroutine 기능을 내장하고 있어서 간단함.

***************************************************************************************

이하는 개발 초기에 작성한 것임.

이미 많이 달라졌음.

***************************************************************************************

전략그룹 - 전략 인스턴스 (초도신호, 주문전송, 주문처리결과 담당) - 초도신호(후속신호 담당)

 |

서버 : 전략관리모듈, 가격정보제공모듈, 주문처리모듈, 증권사모듈등을 가진다.
	  증권사모듈을 가상모듈로 교체하면 백테스팅 시뮬레이션이 된다.
	  증권사모듈을 모의투자서버모듈로 교체하면 페이퍼 트레이딩이 된다.


가격정보의 흐름 : 증권사모듈 -> 가격정보제공모듈 -> 서버 -> 전략그룹 -> 전략, 초도신호
주문정보의 흐름 : 전략(초도신호), 초도신호(후속신호) -> 서버 -> 주문처리모듈 -> 증권사모듈
주문처리결과정보의 흐름 : 증권사모듈 -> 주문을 발생한 전략 (주문에 회신채널이 포함되어 있음).

서버는 중간에서 채널을 중개해 주고, 정보흐름의 중간 물류센터 역할을 한다.
서버 하위모듈에서 직접 가격정보와 주문처리결과를 회신할 수도 있지만,
모의서버에서는 버퍼링없이 순차적으로 처리해야하는 요구사항으로 인해서,
서버에서 주문의 흐름을 통제할 수 있도록 일부러 서버를 거쳐서 전달되도록 한다.
이렇게 함으로써 성능 상 손실이 있겠지만, 백테스팅을 마친 전략을 바로 실전에 투입할 수 있게 된다.


모의서버에서는 가격정보 전송과 주문처리의 동시처리 숫자를 0으로 설정함으로써,
서버와 전략모듈 간에 순서대로 1개씩 전송 및 처리되도록 한다.

모의서버 흐름도
- 파일에서 가격정보 읽어들이기
- 날짜순으로 정렬
- 오래된 가격정보부터 전략그룹으로 전송하기 (버퍼 0으로 설정해서 순차적 처리)
- 전략 및 미청산 신호에서 계산.
- 신호미생성 시 다음 가격정보 읽기.
- 신호생성 시 주문전송 후 처리결과를 받아서 매매기록 작성하고 포트폴리오 갱신 후 다음 가격정보 읽기.
- 주문처리 모듈에서 주문의 관련신호의 가격정보시점을 기준가격으로 체결처리하고 처리결과 전송.




상수형이 필요한 이유.
동시처리(concurrent) 모듈에서 공유하는 모든 자료는 경쟁조건(racing condition)이 발생할 가능성을 가지고 있다.
자료공유시 발생하는 문제를 원천적으로 해결하는 방법으로 Go언어는 모든 자료는 공유되지 않고, 단지 교환된다는 원칙을 가지고 있지만, 교환되는 정보가 독립적이지 않으면 결국 공유되는 결과를 초래한다.
자료의 독립성을 보장하는 가장 기본적인 2가지 방법은 다음과 같다.
1. 복사본 전달 : Go언어는 값전달(Passing by Value)원칙을 지켜서 이것이 상당히 용이한 편이지만, 참조형(reference type)의 경우에는 이것으로 충분하지 않을 수 있다.
2. 원천적으로 변경할 수 없는 자료(immutable)를 전달 : 다기능을 지향하는 Scala에서는 immutable형식과  mutable형식을 엄격하게 구분해서 제공하지만, 단순하고 빠른 처리를 지향하는 Go언어에서는 구조체(struct)의 멤버변수를 외부에 공개하지 않고, 메소드를 통해서 읽을 수 있되 변경할 수 없도록 보장하는 방식으로 immutable형식으로 자체적으로 제작해서 써야 한다.
이렇게 자체적으로 제작한 immutable 구조체를 상수형 구조체라고 부르기로 한다.

모든 상수형 구조체는 또 다른 상수형 구조체의 포인터, 채널(chan),  슬라이스(slice [])로 이루어져야 한다.
맵(map)은 그 자체로 reference타입이므로 주고 받을 때는 반드시 복사를 거친 복사본을 주고 받도록 하여서 상수형 구조체의 변경불가능성(immutable)을 유지하도록 한다.

 
전략그룹 : 같은 로직에 파라메터가 다른 개별 전략 인스턴스를 묶어서 관리하는 단위.
전략 : 초도신호를 낸다.                 
초도신호 : 후속 추가매수 및 매도 신호를 낸다.
모든 신호는 개별 전략 인스턴스의 위험관리 모듈을 거쳐서 주문전송 여부와 거래금액을 결정한다.
(위험관리 모듈을 개별 전략 인스턴스가 아니라 전략그룹 수준으로 바꾸는 것은 어떨까?)



위험관리
: 전략이 신호를 생성한 후, 
  그 신호에 대해서 실제 주문을 낼 건지 여부
	- 현재의 잠재손실 최대치가 감당가능한 범위를 넘어선다면 추가매수 허용하지 않음.
	- halt-Kelly : 각 전략별 half-Kelly 허용비율 혹은 허용금액이 넘어섰다면 추가매수 허용하지 않음.
	- 역사적 최대손실 : 역사적 최대손실 비율를 고려해서 감당가능한 금액 혹은 전체 자산에서 비율을 넘어서면 추가매수 허용하지 않음.
	- 하나의 전략이 전체 위험자산 배정금액에서 차지하는 비율이 일정기준을 넘어섰다면 추가매수 허용하지 않음.
		(하버드의 피셔 교수, LTCM, Amaranth Advisors 모두 단 1개의 전략에 너무 많은 금액을 투자했다가 순식간에 망했음.
		대부분의 경우 잘 나가던 투자자가 단 1번에 거덜나는 전략은 이전에 수익률이 높았던 전략임.)    
	- 기타 거시경제 지표등을 기준으로 진입기준을 만족시키지 못하거나, 진입금지 기준을 만족시킬 경우 추가매수 허용하지 않음.
	- 개별종목이 전체 자산에서 차지하는 비중을 일정수준(예 : 15%) 이하로 유지.

   주문낼 경우 금액은 얼마로 할 지(과거 실적과 리스크에 따라 전략별 최대한도 설정) 결정.
	- 해당 주문의 잠재적인 최대손실액을 전략 최대한도의 일정 % 이내로 한정짓기?
	- half-Kelly 공식 한도 내에서 움직이기
	- 역사적 최대손실에 비추어 감당가능한 한도 내에서 움직이기.


로그분석
확인 : 주기적으로 컴퓨터가 관리하는 포트폴리오와 실제 계정의 내역이 일치하는 지 확인하는 게 필요함.