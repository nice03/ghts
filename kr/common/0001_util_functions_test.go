package common

import (
	"fmt"
	"math/big"
	"math/rand"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"time"
)

func TestF_nil_존재함(테스트 *testing.T) {
	F참인지_확인(테스트, F_nil_존재함(nil), "")
	F참인지_확인(테스트, F_nil_존재함(1, nil, "test", 1.1), "")
	F거짓인지_확인(테스트, F_nil_존재함(1, "test", 1.1), "")
}

func TestF부호없는_정수2큰정수(테스트 *testing.T) {
	원래값 := uint64(1001)
	var 변환값 *big.Int = F부호없는_정수2큰정수(원래값)

	참거짓 := 변환값.Cmp(new(big.Int).SetUint64(원래값)) == 0

	F참인지_확인(테스트, 참거짓, "TestF부호없는_정수2큰정수() : 원래값  %v, 변환값 %v", 원래값, 변환값)
}

func TestF부호없는_정수2정밀수(테스트 *testing.T) {
	원래값 := uint64(1001)
	var 변환값 *big.Rat = F부호없는_정수2정밀수(원래값)

	참거짓 := 변환값.Cmp(new(big.Rat).SetInt(F부호없는_정수2큰정수(원래값))) == 0

	F참인지_확인(테스트, 참거짓, "TestF부호없는_정수2정밀수() : 원래값  %v, 변환값 %v", 원래값, 변환값)
}

func TestF부호없는_정수2문자열(테스트 *testing.T) {
	F같은값_확인(테스트, F부호없는_정수2문자열(100), "100")
}

func TestF정수2큰정수(테스트 *testing.T) {
	원래값 := int64(100)
	var 변환값 *big.Int = F정수2큰정수(원래값)
	
	참거짓 := 변환값.Cmp(big.NewInt(원래값)) == 0
	
	F참인지_확인(테스트, 참거짓, "TestF정수2큰정수() : 원래값 %v, 변환값 %v", 원래값, 변환값)
}

func TestF정수2정밀수(테스트 *testing.T) {
	원래값 := int64(1001)
	var 변환값 *big.Rat = F정수2정밀수(원래값)

	참거짓 := 변환값.Cmp(new(big.Rat).SetInt64(원래값)) == 0

	F참인지_확인(테스트, 참거짓, "TestF정수2정밀수() : 원래값  %v, 변환값 %v", 원래값, 변환값)
}

func TestF정수2문자열(테스트 *testing.T) {
	F같은값_확인(테스트, F정수2문자열(int64(100)), "100")
}

func TestF정수2월(테스트 *testing.T) {
	월, 에러 := F정수2월(1)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 월, time.January)
	
	월, 에러 = F정수2월(13)
	F에러발생_확인(테스트, 에러)
}

func TestF실수2정밀수(테스트 *testing.T) {
	원래값 := float64(1001.020023)
	var 변환값 *big.Rat = F실수2정밀수(원래값)

	참거짓 := 변환값.FloatString(6) == "1001.020023"

	F참인지_확인(테스트, 참거짓, "TestF실수2정밀수() : 원래값  %v, 변환값 %v", 원래값, 변환값)
}

func TestF실수2문자열(테스트 *testing.T) {
	F같은값_확인(테스트, F실수2문자열(100.25), "100.25")
}

func TestF큰정수(테스트 *testing.T) {
	도우미_F큰정수_에러(테스트, nil)
	
	예상값 := big.NewInt(100)
	도우미_F큰정수(테스트, uint(100), 예상값)
	도우미_F큰정수(테스트, uint8(100), 예상값)
	도우미_F큰정수(테스트, uint16(100), 예상값)
	도우미_F큰정수(테스트, uint32(100), 예상값)
	도우미_F큰정수(테스트, uint64(100), 예상값)
	도우미_F큰정수(테스트, int(100), 예상값)
	도우미_F큰정수(테스트, int8(100), 예상값)
	도우미_F큰정수(테스트, int16(100), 예상값)
	도우미_F큰정수(테스트, int32(100), 예상값)
	도우미_F큰정수(테스트, int64(100), 예상값)
	
	도우미_F큰정수_에러(테스트, float32(100.02))
	도우미_F큰정수_에러(테스트, float64(100.02))
	
	예상값 = big.NewInt(1000)
	큰정수_참조형 := big.NewInt(1000)
	도우미_F큰정수(테스트, 큰정수_참조형, 예상값)
	도우미_F큰정수(테스트, *큰정수_참조형, 예상값)
	
	정밀수_참조형 := big.NewRat(100250, 1000)
	도우미_F큰정수_에러(테스트, 정밀수_참조형)
	도우미_F큰정수_에러(테스트, *정밀수_참조형)
	
	예상값 = big.NewInt(100)
	도우미_F큰정수(테스트, NC부호없는_정수(100), 예상값)
	도우미_F큰정수(테스트, NC정수(100), 예상값)
	도우미_F큰정수(테스트, NC큰정수(100), 예상값)
	
	도우미_F큰정수_에러(테스트, NC실수(100.025))
	도우미_F큰정수_에러(테스트, NC통화(KRW, 100.025))
	
	도우미_F큰정수_에러(테스트, "100.1")
	도우미_F큰정수_에러(테스트, NC문자열("100.1"))
	
	도우미_F큰정수_에러(테스트, "변환 불가능한 문자열")
	도우미_F큰정수_에러(테스트, NC문자열("변환 불가능한 문자열"))
}

func 도우미_F큰정수(테스트 *testing.T, 원본값 interface{}, 예상값 *big.Int) {
	큰정수, 에러 := F큰정수(원본값)
	
	F에러없음_확인(테스트, 에러)	
	F참인지_확인(테스트, 
				큰정수.Cmp(예상값) == 0, 
				" 원본값 %v %v, 예상값 %v %v, 실제값 %v %v", 
				reflect.TypeOf(원본값), 원본값,  
				reflect.TypeOf(예상값), 예상값,
				reflect.TypeOf(큰정수), 큰정수)
}

func 도우미_F큰정수_에러(테스트 *testing.T, 원본값 interface{}) {
	큰정수, 에러 := F큰정수(원본값)
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 큰정수 == nil, "")
}

func TestF큰정수_복사(테스트 *testing.T) {
	입력값 := big.NewInt(100)
	입력값_백업 := big.NewInt(100)
	복사값 := F큰정수_복사(입력값)
	
	F같은값_확인(테스트, 입력값, 입력값_백업)
	F같은값_확인(테스트, 입력값, 복사값)
	
	입력값.Add(입력값, big.NewInt(10))
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 입력값, 복사값)
	F같은값_확인(테스트, 복사값, 입력값_백업)	
}

func TestF큰정수2실수(테스트 *testing.T) {
	입력값 := big.NewInt(1001)
	var 변환값 float64 = F큰정수2실수(입력값)

	참거짓 := 변환값 - float64(입력값.Int64()) == 0

	F참인지_확인(테스트, 참거짓, "TestF큰정수2정밀수() : 입력값  %v, 변환값 %v", 입력값, 변환값)
}

func TestF큰정수2정밀수(테스트 *testing.T) {
	입력값 := big.NewInt(1001)
	var 변환값 *big.Rat = F큰정수2정밀수(입력값)

	참거짓 := 변환값.Cmp(big.NewRat(입력값.Int64(), 1)) == 0

	F참인지_확인(테스트, 참거짓, "TestF큰정수2정밀수() : 입력값  %v, 변환값 %v", 입력값, 변환값)
}

func TestF큰정수_절대값(테스트 *testing.T) {
	입력값 := big.NewInt(-100)
	출력값 := F큰정수_절대값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewInt(100))
	
	입력값 = big.NewInt(100)
	출력값 = F큰정수_절대값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewInt(100))
}

func TestF큰정수_더하기(테스트 *testing.T) {
	입력값1 := big.NewInt(100)
	입력값2 := big.NewInt(100)
	출력값 := F큰정수_더하기(입력값1, 입력값2)
	
	F같은값_확인(테스트, 출력값, big.NewInt(200))
}

func TestF큰정수_빼기(테스트 *testing.T) {
	입력값1 := big.NewInt(100)
	입력값2 := big.NewInt(100)
	출력값 := F큰정수_빼기(입력값1, 입력값2)
	
	F같은값_확인(테스트, 출력값, big.NewInt(0))
}

func TestF큰정수_곱하기(테스트 *testing.T) {
	입력값1 := big.NewInt(100)
	입력값2 := big.NewInt(100)
	출력값 := F큰정수_곱하기(입력값1, 입력값2)
	
	F같은값_확인(테스트, 출력값, big.NewInt(10000))
}

func TestF큰정수_나누기(테스트 *testing.T) {
	입력값1 := big.NewInt(100)
	입력값2 := big.NewInt(100)
	출력값, 에러 := F큰정수_나누기(입력값1, 입력값2)
	
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewInt(1))
	
	입력값1 = big.NewInt(100)
	입력값2 = big.NewInt(0)
	출력값, 에러 = F큰정수_나누기(입력값1, 입력값2)
	
	F에러발생_확인(테스트, 에러)	
	F참인지_확인(테스트, 출력값 == nil, "")
}

func TestF큰정수_반대부호값(테스트 *testing.T) {
	입력값 := big.NewInt(-100)
	출력값 := F큰정수_반대부호값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewInt(100))
	
	입력값 = big.NewInt(100)
	출력값 = F큰정수_반대부호값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewInt(-100))
}

func TestF정밀수(테스트 *testing.T) {
	도우미_F정밀수_에러(테스트, nil)
	
	예상값 := big.NewRat(100,1)
	도우미_F정밀수(테스트, uint(100), 예상값)
	도우미_F정밀수(테스트, uint8(100), 예상값)
	도우미_F정밀수(테스트, uint16(100), 예상값)
	도우미_F정밀수(테스트, uint32(100), 예상값)
	도우미_F정밀수(테스트, uint64(100), 예상값)
	도우미_F정밀수(테스트, int(100), 예상값)
	도우미_F정밀수(테스트, int8(100), 예상값)
	도우미_F정밀수(테스트, int16(100), 예상값)
	도우미_F정밀수(테스트, int32(100), 예상값)
	도우미_F정밀수(테스트, int64(100), 예상값)
	
	예상값 = big.NewRat(10002,100)
	도우미_F정밀수(테스트, float32(100.02), 예상값)
	도우미_F정밀수(테스트, float64(100.02), 예상값)
	
	예상값 = big.NewRat(1000,1)
	큰정수_참조형 := big.NewInt(1000)
	도우미_F정밀수(테스트, 큰정수_참조형, 예상값)
	도우미_F정밀수(테스트, *큰정수_참조형, 예상값)
	
	예상값 = big.NewRat(10025, 100)
	정밀수_참조형 := big.NewRat(100250, 1000)
	도우미_F정밀수(테스트, 정밀수_참조형, 예상값)
	도우미_F정밀수(테스트, *정밀수_참조형, 예상값)
	
	예상값 = big.NewRat(100, 1)
	도우미_F정밀수(테스트, NC부호없는_정수(100), 예상값)
	도우미_F정밀수(테스트, NC정수(100), 예상값)
	도우미_F정밀수(테스트, NC큰정수(100), 예상값)
	
	예상값 = big.NewRat(100025, 1000)
	도우미_F정밀수(테스트, NC실수(100.025), 예상값)
	도우미_F정밀수(테스트, NC정밀수(100.025), 예상값)
	
	예상값 = big.NewRat(100, 1)
	도우미_F정밀수(테스트, NC통화(KRW, 100.025), 예상값)
	
	도우미_F정밀수(테스트, "100", 예상값)
	도우미_F정밀수(테스트, NC문자열("100"), 예상값)
	
	도우미_F정밀수_에러(테스트, "변환 불가능한 문자열")
	도우미_F정밀수_에러(테스트, NC문자열("변환 불가능한 문자열"))
}

func 도우미_F정밀수(테스트 *testing.T, 원본값 interface{}, 예상값 *big.Rat) {
	정밀수, 에러 := F정밀수(원본값)
	
	F에러없음_확인(테스트, 에러)
	
	F같은값_확인(테스트, 정밀수, 예상값)
	
	/*
	참거짓 := 정밀수.Cmp(예상값) == 0
	
	F참인지_확인(테스트, 참거짓, " 원본값 %v %v, 예상값 %v %v, 실제값 %v %v", 
				reflect.TypeOf(원본값), 원본값,  
				reflect.TypeOf(예상값), 예상값,
				reflect.TypeOf(정밀수), 정밀수) */
}

func 도우미_F정밀수_에러(테스트 *testing.T, 원본값 interface{}) {
	정밀수, 에러 := F정밀수(원본값)
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 정밀수 == nil, "")
}

func TestF정밀수_같음(테스트 *testing.T) {	
	정밀수1 := big.NewRat(1001, 10)
	정밀수2 := big.NewRat(1001, 10)
	
	F참인지_확인(테스트, F정밀수_같음(정밀수1, 정밀수2))
	
	정밀수2 = big.NewRat(1002, 10)
	
	F거짓인지_확인(테스트, F정밀수_같음(정밀수1, 정밀수2))
	
	작은_수, _ := new(big.Rat).SetString(
						"1/100000000000000000000000000000000000000000000")
	정밀수2 = big.NewRat(1001, 10).Add(정밀수1, 작은_수)
	
	F참인지_확인(테스트, F정밀수_같음(정밀수1, 정밀수2))
}

func TestF정밀수_복사(테스트 *testing.T) {
	원래값 := big.NewRat(1001, 10)
	예상값 := big.NewRat(1001, 10)
	복사값 := F정밀수_복사(원래값)
	
	F같은값_확인(테스트, 복사값, 예상값)
	
	원래값.Add(원래값, big.NewRat(100, 1))
	
	F같은값_확인(테스트, 복사값, 예상값)

}

func TestF정밀수2실수(테스트 *testing.T) {
	실수 := F정밀수2실수(big.NewRat(1001, 10))
	
	F같은값_확인(테스트, 실수, 100.1)
}

func TestF정밀수2문자열(테스트 *testing.T) {
	F같은값_확인(테스트, F정밀수2문자열(big.NewRat(100340, 1000)), "100.34")
}

func TestF정밀수_반올림값(테스트 *testing.T) {
	정밀수 := big.NewRat(1000454, 10000)	// 100.0454
	
	F같은값_확인(테스트, F정밀수_반올림값(정밀수, 2), 100.05)
	F같은값_확인(테스트, F정밀수_반올림값(정밀수, 3), 100.045)
	F같은값_확인(테스트, F정밀수_반올림값(정밀수, 4), 100.0454)
}

func TestF정밀수_반올림값Big(테스트 *testing.T) {
	정밀수 := big.NewRat(1000454, 10000)	// 100.0454
	
	F같은값_확인(테스트, F정밀수_반올림값Big(정밀수, 2), 100.05)
	F같은값_확인(테스트, F정밀수_반올림값Big(정밀수, 3), 100.045)
	F같은값_확인(테스트, F정밀수_반올림값Big(정밀수, 4), 100.0454)
}

func TestF정밀수_반올림_문자열(테스트 *testing.T) {
	정밀수 := big.NewRat(104594, 10000)
	F같은값_확인(테스트, F정밀수_반올림_문자열(정밀수, 4), "10.4594")
	F같은값_확인(테스트, F정밀수_반올림_문자열(정밀수, 3), "10.459")
	F같은값_확인(테스트, F정밀수_반올림_문자열(정밀수, 2), "10.46")
	F같은값_확인(테스트, F정밀수_반올림_문자열(정밀수, 1), "10.5")
	F같은값_확인(테스트, F정밀수_반올림_문자열(정밀수, 0), "10")
}

func TestF정밀수_절대값(테스트 *testing.T) {
	입력값 := big.NewRat(-1001, 10)
	출력값 := F정밀수_절대값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))
	
	입력값 = big.NewRat(1001, 10)
	출력값 = F정밀수_절대값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))
}

func TestF정밀수_더하기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값 := F정밀수_더하기(입력값1, 입력값2)
	
	F같은값_확인(테스트, 출력값, big.NewRat(2002, 10))
}

func TestF정밀수_빼기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값 := F정밀수_빼기(입력값1, 입력값2)
	
	F같은값_확인(테스트, 출력값, big.NewRat(0, 1))
}

func TestF정밀수_곱하기(테스트 *testing.T) {
	입력값1 := big.NewRat(100, 1)
	입력값2 := big.NewRat(100, 1)
	출력값 := F정밀수_곱하기(입력값1, 입력값2)
	
	F같은값_확인(테스트, 출력값, big.NewRat(10000, 1))
}

func TestF정밀수_나누기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값, 에러 := F정밀수_나누기(입력값1, 입력값2)
	
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewRat(1, 1))
	
	// 에러가 발생하는 것을 어떻게 처리해야 하나?
	입력값1 = big.NewRat(1001, 10)
	입력값2 = big.NewRat(0, 1)
	출력값, 에러 = F정밀수_나누기(입력값1, 입력값2)
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 출력값 == nil, "")
}

func TestF정밀수_역수(테스트 *testing.T) {
	입력값 := big.NewRat(1001, 10)
	출력값, 에러 := F정밀수_역수(입력값)
	
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewRat(10, 1001))
	
	입력값 = big.NewRat(0, 1)
	출력값, 에러 = F정밀수_역수(입력값)
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 출력값 == nil, "")	
}

func TestF정밀수_반대부호값(테스트 *testing.T) {
	입력값 := big.NewRat(-1001, 10)
	출력값 := F정밀수_반대부호값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))
	
	입력값 = big.NewRat(1001, 10)
	출력값 = F정밀수_반대부호값(입력값)
	
	F같은값_확인(테스트, 출력값, big.NewRat(-1001, 10))
}

func TestF통화_복사(테스트 *testing.T) {
	// 통화종류를 매번 다르게 선택하기.
	통화종류_모음 := []P통화{KRW, USD, CNY, EUR}
	통화종류 := 통화종류_모음[rand.Int31n(int32(len(통화종류_모음) - 1))]
	
	c통화1 := NC통화(통화종류, 100)
	c통화2 := F통화_복사(c통화1)
	
	F참인지_확인(테스트, F통화_같음(c통화1, c통화2))
	
	v통화1 := NV통화(통화종류, 100)
	v통화2 := F통화_복사(v통화1)
	
	F참인지_확인(테스트, F통화_같음(v통화1, v통화2))
	
	v통화1.S셀프_더하기(NC통화(통화종류, 100))
	
	F거짓인지_확인(테스트, F통화_같음(v통화1, v통화2))
}

func TestF통화_같음(테스트 *testing.T) {
	F참인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화Big(KRW, big.NewRat(100, 1))))
	F참인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화Big(KRW, big.NewRat(100, 1))))
	F참인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NV통화(KRW, 100)))
	F참인지_확인(테스트, F통화_같음(NC통화Big(KRW, big.NewRat(100, 1)), 
					NV통화Big(KRW, big.NewRat(100, 1))))
	
	// 통화종류만 바꾸어도 달라야 함.
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화(USD, 100)))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화(USD, 100)))
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화Big(USD, big.NewRat(100, 1))))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화Big(USD, big.NewRat(100, 1))))
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화Big(USD, big.NewRat(100, 1))))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NC통화(USD, 100)))
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NV통화Big(USD, big.NewRat(100, 1))))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화(USD, 100)))
	
	// 통화 금액만 바꾸어도 달라야 함.
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화(KRW, 10)))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화(KRW, 10)))
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화Big(KRW, big.NewRat(10, 1))))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화Big(KRW, big.NewRat(10, 1))))
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NC통화Big(KRW, big.NewRat(10, 1))))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NC통화(KRW, 10)))
	F거짓인지_확인(테스트, F통화_같음(NC통화(KRW, 100), NV통화Big(KRW, big.NewRat(10, 1))))
	F거짓인지_확인(테스트, F통화_같음(NV통화(KRW, 100), NV통화(KRW, 10)))
}

func TestF참거짓2문자열(테스트 *testing.T) {
	F같은값_확인(테스트, F참거짓2문자열(true), "true")
	F같은값_확인(테스트, F참거짓2문자열(false), "false")
}

func TestF문자열2실수(테스트 *testing.T) {
	실수, 에러 := F문자열2실수("18.593")

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 실수, 18.593)
	
	실수, 에러 = F문자열2실수("실수로 변환 불가능한 문자열")
	
	F에러발생_확인(테스트, 에러)
}

func TestF문자열2큰정수(테스트 *testing.T) {
	큰정수, 에러 := F문자열2큰정수("100")

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 큰정수, big.NewInt(100))
	
	큰정수, 에러 = F문자열2큰정수("100.1")
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 큰정수 == nil, "")
	
	큰정수, 에러 = F문자열2큰정수("실수로 변환 불가능한 문자열")
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 큰정수 == nil, "")
}

func TestF문자열2정밀수(테스트 *testing.T) {
	정밀수, 에러 := F문자열2정밀수("100")

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 정밀수, big.NewRat(100, 1))
	
	정밀수, 에러 = F문자열2정밀수("100.1")
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 정밀수, big.NewRat(1001, 10))
	
	정밀수, 에러 = F문자열2정밀수("정밀수로 변환 불가능한 문자열")
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 정밀수 == nil, "")
}

func TestF문자열2일자(테스트 *testing.T) {
	일자, 에러 := F문자열2일자("2000-01-01")
	
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 일자.Format("2006-01-02"), "2000-01-01")

	일자, 에러 = F문자열2일자("변환 불가능한 문자열")
	F에러발생_확인(테스트, 에러)
}

func TestF일자2문자열(테스트 *testing.T) {
	월, _ := F정수2월(1)
	일자 := time.Date(2000, 월, 1, 0, 0, 0, 0, time.Now().Location())

	F같은값_확인(테스트, F일자2문자열(일자), "2000-01-01")
}

func TestF시점_복사(테스트 *testing.T) {
	시점 := time.Now()
	복사본 := F시점_복사(시점)
	
	F같은값_확인(테스트, 시점, 복사본)
	
	시점 = 시점.AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 시점, 복사본)
}

func TestF값_같음(테스트 *testing.T) {
	// 정수 테스트
	값 := []interface{}{
			uint(100), uint8(100), uint16(100), uint32(100), uint64(100),
			int(100), int8(100), int16(100), int32(100), int64(100),
			float32(100.0), float64(100.0),
			NC큰정수(100), NV큰정수(100), NC정밀수(100), NV정밀수(100)}
	
	testF값_같음_도우미(테스트, 값)
	
	// 실수 테스트
	값 = []interface{}{
			float32(100.0345), float64(100.0345),
			NC정밀수(100.0345), NV정밀수(100.0345)}
	
	testF값_같음_도우미(테스트, 값)
	
	// 정밀한 실수 테스트
	값 = []interface{}{
			//float32(100.000000345), // float32에서는 에러남.
			float64(100.000000345),
			NC정밀수(100.000000345), NV정밀수(100.000000345)}
	
	testF값_같음_도우미(테스트, 값)
	
	// 통화 테스트
	// 통화종류를 매번 다르게 선택하기.
	통화종류_모음 := []P통화{KRW, USD, CNY, EUR}
	통화종류 := 통화종류_모음[rand.Int31n(int32(len(통화종류_모음) - 1))]
	
	값 = []interface{}{
			NC통화(통화종류, 111.1111), 
			NC통화Big(통화종류, big.NewRat(1111111, 10000)),
			NV통화(통화종류, 111.1111),
			NV통화Big(통화종류, big.NewRat(1111111, 10000))}
			 
	testF값_같음_도우미(테스트, 값)
}

func testF값_같음_도우미(테스트 *testing.T, 값 []interface{}) {
	for 인덱스1 := 0 ; 인덱스1 < (len(값) - 1) ; 인덱스1++ {
		for 인덱스2 := 인덱스1 + 1 ; 인덱스2 < len(값) ; 인덱스2++ {
			F참인지_확인(테스트, F값_같음(값[인덱스1], 값[인덱스2]),
						"common.TestF값_값음() : 값1 %v %v, 값2 %v %v",
						reflect.TypeOf(값[인덱스1]), 값[인덱스1],
						reflect.TypeOf(값[인덱스2]), 값[인덱스2])
		}
	}
}

type i테스트_인터페이스를_구현함_a interface {
	a()
}
type i테스트_인터페이스를_구현함_b interface {
	b()
}

type s테스트_인터페이스를_구현함_a struct{}

func (s *s테스트_인터페이스를_구현함_a) a() {}

type s테스트_인터페이스를_구현함_b struct{}

func (s *s테스트_인터페이스를_구현함_b) b() {}

func TestF인터페이스를_구현함(테스트 *testing.T) {
	ia := reflect.TypeOf((*i테스트_인터페이스를_구현함_a)(nil)).Elem()
	ib := reflect.TypeOf((*i테스트_인터페이스를_구현함_b)(nil)).Elem()

	sa := new(s테스트_인터페이스를_구현함_a)
	sb := new(s테스트_인터페이스를_구현함_b)

	참거짓 := F인터페이스를_구현함(sa, ia)
	포맷_문자열 := "예상과 다른 결과. 값 %v 인터페이스 %v 구현 여부 %v"
	F참인지_확인(테스트, 참거짓, 포맷_문자열, reflect.TypeOf(sa), reflect.TypeOf(ia), 참거짓)

	참거짓 = F인터페이스를_구현함(sa, ib)
	F거짓인지_확인(테스트, 참거짓, 포맷_문자열, reflect.TypeOf(sa), reflect.TypeOf(ib), 참거짓)

	참거짓 = F인터페이스를_구현함(sb, ia)
	F거짓인지_확인(테스트, 참거짓, 포맷_문자열, reflect.TypeOf(sb), reflect.TypeOf(ia), 참거짓)

	참거짓 = F인터페이스를_구현함(sb, ib)
	F참인지_확인(테스트, 참거짓, 포맷_문자열, reflect.TypeOf(sb), reflect.TypeOf(ib), 참거짓)
}

func TestF슬라이스_복사(테스트 *testing.T) {
	원본_슬라이스 := []string{"1번째", "2번째", "3번째"}
	복사본_슬라이스 := F슬라이스_복사(원본_슬라이스).([]string)

	F같은값_확인(테스트, len(원본_슬라이스), len(복사본_슬라이스))
	F같은값_확인(테스트, 원본_슬라이스[0], 복사본_슬라이스[0])
	F같은값_확인(테스트, 원본_슬라이스[1], 복사본_슬라이스[1])
	F같은값_확인(테스트, 원본_슬라이스[2], 복사본_슬라이스[2])

	// 원본과 복사본의 독립성 확인.
	복사본_슬라이스[0] = "변경된 1번째"
	F다른값_확인(테스트, 원본_슬라이스[0], 복사본_슬라이스[0])
}

func TestF체크포인트(테스트 *testing.T) {
	/*
		체크포인트_번호 := 1
		F체크포인트("TestF체크포인트", &체크포인트_번호)
		F체크포인트("TestF체크포인트", &체크포인트_번호)
		F체크포인트("TestF체크포인트", &체크포인트_번호)
	*/
}

func TestF소스코드_위치(테스트 *testing.T) {
	소스코드_위치 := strings.Split(F소스코드_위치(0), ":")
	파일명, 행_번호 := 소스코드_위치[0], 소스코드_위치[1]
	
	F참인지_확인(테스트, strings.HasPrefix(파일명, "0001_"),
		"TestF소스코드_위치() : F소스코드_위치() 파일명_에러. 값 %v", 파일명)

	F참인지_확인(테스트, strings.HasSuffix(파일명, ".go"),
		"TestF소스코드_위치() : F소스코드_위치() 파일명_에러. 값 %v", 파일명)

	소스코드_위치 = strings.Split(F소스코드_위치(1), ":")
	파일명, 행_번호 = 소스코드_위치[0], 소스코드_위치[1]
	_, _, 행_번호_예상값, _ := runtime.Caller(0)

	F참인지_확인(테스트, strings.HasPrefix(파일명, "0001_"),
		"TestF소스코드_위치() : F소스코드_위치() 파일명_에러. 값 %v", 파일명)

	F참인지_확인(테스트, strings.HasSuffix(파일명, "_test.go"),
		"TestF소스코드_위치() : F소스코드_위치() 파일명_에러. 값 %v", 파일명)

	F같은값_확인(테스트, F정수2문자열(int64(행_번호_예상값-2)), 행_번호)
}

// 테스트 편의함수 Fxxx_확인() 테스트용 Mock-Up
// testing.TB 인터페이스를 구현함.
var 테스트_통과 bool = true

type s가상TB struct{ *testing.T }

func (s s가상TB) Error(args ...interface{})                 { 테스트_통과 = false }
func (s s가상TB) Errorf(format string, args ...interface{}) { 테스트_통과 = false }
func (s s가상TB) Fail()                                     { 테스트_통과 = false }
func (s s가상TB) FailNow()                                  { 테스트_통과 = false }
func (s s가상TB) Failed() bool                              { return !테스트_통과 }
func (s s가상TB) Fatal(args ...interface{})                 { 테스트_통과 = false }
func (s s가상TB) Fatalf(format string, args ...interface{}) { 테스트_통과 = false }
func (s s가상TB) Log(args ...interface{})                   {}
func (s s가상TB) Logf(format string, args ...interface{})   {}
func (s s가상TB) Skip(args ...interface{})                  {}
func (s s가상TB) SkipNow()                                  {}
func (s s가상TB) Skipf(format string, args ...interface{})  {}
func (s s가상TB) Skipped() bool                             { return false }
func (s s가상TB) 테스트용_가상_객체()                               {}

func TestS가상TB(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)
	var tb testing.TB = 가상_테스트
	tb.Failed()
	var i테스트용_가상_객체 I테스트용_가상_객체 = 가상_테스트
	i테스트용_가상_객체.테스트용_가상_객체()

	테스트_통과 = true
	가상_테스트.Error()
	if 테스트_통과 || !가상_테스트.Failed() {
		테스트.Errorf("TestS가상TB() : 에러 1")
	}

	테스트_통과 = true
	가상_테스트.Errorf("")
	if 테스트_통과 || !가상_테스트.Failed() {
		테스트.Errorf("TestS가상TB() : 에러 2")
	}

	테스트_통과 = true
	가상_테스트.Fail()
	if 테스트_통과 || !가상_테스트.Failed() {
		테스트.Errorf("TestS가상TB() : 에러 3")
	}

	테스트_통과 = true
	가상_테스트.FailNow()
	if 테스트_통과 || !가상_테스트.Failed() {
		테스트.Errorf("TestS가상TB() : 에러 4")
	}

	테스트_통과 = true
	가상_테스트.Fatal()
	if 테스트_통과 || !가상_테스트.Failed() {
		테스트.Errorf("TestS가상TB() : 에러 5")
	}

	테스트_통과 = true
	가상_테스트.Fatalf("")
	if 테스트_통과 || !가상_테스트.Failed() {
		테스트.Errorf("TestS가상TB() : 에러 6")
	}
}

func TestF참인지_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)
	
	// 간단한 형식
	테스트_통과 = true
	테스트_결과_반환값 := F참인지_확인(가상_테스트, true)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F참인지_확인(가상_테스트, false)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}
	
	// 포맷 문자열 있는 폼
	테스트_통과 = true
	테스트_결과_반환값 = F참인지_확인(가상_테스트, true, "포맷_문자열")
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F참인지_확인(가상_테스트, false, "포맷_문자열")
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}
	
	// 포맷 문자열 없는 폼
	테스트_통과 = true
	테스트_결과_반환값 = F참인지_확인(가상_테스트, true, 1, 2)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F참인지_확인(가상_테스트, false, 1, 2)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}
}

func TestF거짓인지_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)
	
	// 간단한 형식
	테스트_통과 = true
	테스트_결과_반환값 := F거짓인지_확인(가상_테스트, true)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F거짓인지_확인(가상_테스트, false)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}
	
	// 포맷 문자열 있는 폼
	테스트_통과 = true
	테스트_결과_반환값 = F거짓인지_확인(가상_테스트, true, "포맷_문자열")
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F거짓인지_확인(가상_테스트, false, "포맷_문자열")
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}
	
	// 포맷 문자열 없는 폼
	테스트_통과 = true
	테스트_결과_반환값 = F거짓인지_확인(가상_테스트, true, 1, 2)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F거짓인지_확인(가상_테스트, false, 1, 2)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}
}

func TestF에러없음_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)

	테스트_통과 = true
	테스트_결과_반환값 := F에러없음_확인(가상_테스트, nil)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F에러없음_확인(가상_테스트, fmt.Errorf(""))
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}
}

func TestF에러발생_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)

	테스트_통과 = true
	테스트_결과_반환값 := F에러발생_확인(가상_테스트, nil)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F에러발생_확인(가상_테스트, fmt.Errorf(""))
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}
}

func TestF같은값_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)

	테스트_통과 = true
	테스트_결과_반환값 := F같은값_확인(가상_테스트, 1, 1)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F같은값_확인(가상_테스트, 1, 2)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Errorf("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}
}

func TestF다른값_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)

	테스트_통과 = true
	테스트_결과_반환값 := F다른값_확인(가상_테스트, 1, 1)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Error("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F다른값_확인(가상_테스트, 1, 2)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Error("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}
}

/*
func TestFnil_확인(테스트 *testing.T) {
	가상_테스트 := new(s가상TB)

	테스트_통과 = true
	테스트_결과_반환값 := F_nil_확인(가상_테스트, 1)
	if 테스트_통과 || 테스트_결과_반환값 {
		테스트.Error("%s예상치 못한 테스트 통과.", F소스코드_위치(1))
	}

	테스트_통과 = true
	테스트_결과_반환값 = F_nil_확인(가상_테스트, nil)
	if !테스트_통과 || !테스트_결과_반환값 {
		테스트.Error("%s예상치 못한 테스트 실패.", F소스코드_위치(1))
	}
} */
