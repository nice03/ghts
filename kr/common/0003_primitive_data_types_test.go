package common

import (
	"math/big"
	"reflect"
	"testing"
	"time"
)

func TestC정수(테스트 *testing.T) {
	초기값 := int64(10)
	예상값 := int64(10)

	// 생성자 테스트
	var c정수 C정수 = NC정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	정수값 := c정수.G값()
	정수값 = 정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c정수.G값(), 예상값)

	switch c정수.(type) {
	case I변수형:
		테스트.Error("common.TestC정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC부호없는_정수(테스트 *testing.T) {
	초기값 := uint64(10)
	예상값 := uint64(10)

	// 생성자 테스트
	var c부호없는_정수 C부호없는_정수 = NC부호없는_정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	부호없는_정수값 := c부호없는_정수.G값()
	부호없는_정수값 = 부호없는_정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)
	
	switch c부호없는_정수.(type) {
	case I변수형:
		테스트.Error("common.TestC부호없는_정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC실수(테스트 *testing.T) {
	초기값 := float64(10.0)
	예상값 := float64(10.0)

	// 생성자 테스트
	var c실수 C실수 = NC실수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c실수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c실수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	실수값 := c실수.G값()
	실수값 = 실수값 + 10.0 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c실수.G값(), 예상값)

	switch c실수.(type) {
	case I변수형:
		테스트.Error("common.TestC실수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC문자열(테스트 *testing.T) {
	초기값 := "테스트 문자열"
	예상값 := "테스트 문자열"

	// 생성자 테스트
	var c문자열 C문자열 = NC문자열(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + "추가 문자열"

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	문자열값 := c문자열.G값()
	문자열값 = 문자열값 + "추가 문자열" // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	switch c문자열.(type) {
	case I변수형:
		테스트.Error("common.TestC문자열() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC참거짓(테스트 *testing.T) {
	초기값 := true
	예상값 := true

	// 생성자 테스트
	var c참거짓 C참거짓 = NC참거짓(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = !초기값

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	참거짓값 := c참거짓.G값()
	참거짓값 = !참거짓값 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	switch c참거짓.(type) {
	case I변수형:
		테스트.Error("common.TestC참거짓() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func testI시점(테스트 *testing.T, 생성자 interface{}) {
	입력값, _ := F문자열2일자("2000-01-01")
	입력값_백업, _ := F문자열2일자("2000-01-01")
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var 시점 I시점

	// 생성자 테스트
	switch 생성자.(type) {
	case func(time.Time) C시점:
		생성자_ := 생성자.(func(time.Time) C시점)
		시점 = 생성자_(입력값)
	case func(time.Time) V시점:
		생성자_ := 생성자.(func(time.Time) V시점)
		시점 = 생성자_(입력값)
	default:
		panic("testI시점() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 시점.G값(), 입력값)
	
	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값.AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 시점.G값(), 입력값)
	F같은값_확인(테스트, 시점.G값(), 입력값_백업)
	
	// 출력값 변경 후 독립성 확인.
	출력값 := 시점.G값()
	출력값_백업 := F시점_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)
	
	출력값 = 출력값.AddDate(0, 0, 1)
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 시점.G값())
	F같은값_확인(테스트, 출력값_백업, 시점.G값())
}

func TestC시점(테스트 *testing.T) {
	testI시점(테스트, NC시점)

	일자, _ := F문자열2일자("2000-01-01")
	c시점 := NC시점(일자)
	
	switch c시점.(type) {
	case I변수형, V시점:
		테스트.Error("common.TestC시점() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV시점(테스트 *testing.T) {
	testI시점(테스트, NV시점)

	입력값, _ := F문자열2일자("2000-01-01")
	입력값_백업, _ := F문자열2일자("2000-01-01")

	var v시점 V시점 = NV시점(입력값)
	var c시점 C시점 = v시점.G상수형()

	// G상수형() 테스트
	F같은값_확인(테스트, c시점.G값(), 입력값_백업)

	// S값() 테스트. 
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := F시점_복사(입력값).AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 입력값, 바뀐값)

	v시점.S값(바뀐값)

	F같은값_확인(테스트, v시점.G값(), 바뀐값)
	F같은값_확인(테스트, c시점.G값(), 입력값)
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v시점.(type) {
	case I변수형, V시점:
		// OK
	case I상수형, C시점:
		테스트.Error("common.TestV시점() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch v시점.(type) 예상치 못한 경우.")
	}
	
	switch c시점.(type) {
	case I상수형, C시점:
		// OK
	case I변수형, V시점:
		테스트.Error("common.TestV시점() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch c시점.(type) 예상치 못한 경우.")
	}
}

func testI큰정수(테스트 *testing.T, 생성자 interface{}) {
	정수_입력값 := int64(100)
	정수_입력값_백업 := int64(100)
	F같은값_확인(테스트, 정수_입력값, 정수_입력값_백업)
	
	큰정수_입력값 := big.NewInt(정수_입력값)
	큰정수_입력값_백업 := big.NewInt(정수_입력값_백업)
	F같은값_확인(테스트, 큰정수_입력값, 큰정수_입력값_백업)

	var 큰정수 I큰정수

	// 생성자 테스트
	switch 생성자.(type) {
	case func(int64) C큰정수:
		생성자_ := 생성자.(func(int64) C큰정수)
		큰정수 = 생성자_(정수_입력값)
	case func(*big.Int) C큰정수:
		생성자_ := 생성자.(func(*big.Int) C큰정수)
		큰정수 = 생성자_(큰정수_입력값)
	case func(int64) V큰정수:
		생성자_ := 생성자.(func(int64) V큰정수)
		큰정수 = 생성자_(정수_입력값)
	case func(*big.Int) V큰정수:
		생성자_ := 생성자.(func(*big.Int) V큰정수)
		큰정수 = 생성자_(큰정수_입력값)
	default:
		panic("testI큰정수() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 큰정수.G값(), 큰정수_입력값)
	
	// 입력값 변경 후 독립성 확인.
	정수_입력값++
	큰정수_입력값.Add(큰정수_입력값, big.NewInt(10))
	
	F다른값_확인(테스트, 정수_입력값, 정수_입력값_백업)
	F다른값_확인(테스트, 큰정수_입력값, 큰정수_입력값_백업)
	
	F다른값_확인(테스트, 큰정수.G값(), 큰정수_입력값)
	F같은값_확인(테스트, 큰정수.G값(), 큰정수_입력값_백업)
	
	// 출력값 변경 후 독립성 확인.
	출력값 := 큰정수.G값()
	출력값_백업 := F큰정수_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)
	
	출력값.Add(출력값, big.NewInt(10))
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 큰정수.G값())
	F같은값_확인(테스트, 출력값_백업, 큰정수.G값())
}

func TestC큰정수(테스트 *testing.T) {
	testI큰정수(테스트, NC큰정수)

	c큰정수 := NC큰정수(1)
	
	switch c큰정수.(type) {
	case I변수형, V큰정수:
		테스트.Error("common.TestC큰정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV큰정수(테스트 *testing.T) {
	testI큰정수(테스트, NV큰정수)

	입력값 := big.NewInt(100)
	입력값_백업 := big.NewInt(100)
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var v큰정수 V큰정수 = NV큰정수Big(입력값)
	var c큰정수 C큰정수 = v큰정수.G상수형()

	// G상수형() 테스트
	F같은값_확인(테스트, c큰정수.G값(), 입력값)

	// S값() 테스트. 
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := 입력값.Add(입력값, big.NewInt(10))
	
	F다른값_확인(테스트, 바뀐값, 입력값_백업)

	v큰정수.S값Big(바뀐값)

	F같은값_확인(테스트, v큰정수.G값(), 바뀐값)
	F같은값_확인(테스트, c큰정수.G값(), 입력값_백업)
	
	// S절대값() 테스트
	var v큰정수1, v큰정수2, v큰정수3 V큰정수
	
	v큰정수1 = NV큰정수Big(big.NewInt(-100))
	F같은값_확인(테스트, v큰정수1.G값(), big.NewInt(-100))
	
	v큰정수2 = v큰정수1.S절대값(v큰정수1)
	F같은값_확인(테스트, v큰정수2.G값(), big.NewInt(100))
	
	v큰정수1 = NV큰정수Big(big.NewInt(100))
	F같은값_확인(테스트, v큰정수1.G값(), big.NewInt(100))
	
	v큰정수2 = v큰정수1.S절대값(v큰정수1)
	F같은값_확인(테스트, v큰정수2.G값(), big.NewInt(100))
	
	// S빼기() 테스트
	v큰정수1 = NV큰정수(100)
	v큰정수2 = NV큰정수Big(big.NewInt(900))
	v큰정수3 = v큰정수1.S빼기(v큰정수1, v큰정수2)
	
	F같은값_확인(테스트, v큰정수3.G값(), big.NewInt(-800))
	
	// S더하기() 테스트
	v큰정수1 = NV큰정수(100)
	v큰정수2 = NV큰정수(10)
	v큰정수3 = v큰정수1.S더하기(v큰정수1, v큰정수2)
	
	F같은값_확인(테스트, v큰정수3.G값(), big.NewInt(110))
	
	
	// S곱하기() 테스트
	v큰정수1 = NV큰정수(90)
	v큰정수2 = NV큰정수(80)
	v큰정수3 = v큰정수1.S곱하기(v큰정수1, v큰정수2)
	
	F같은값_확인(테스트, v큰정수3.G값(), big.NewInt(7200))
	
	// S나누기() 테스트
	v큰정수1 = NV큰정수(110)
	v큰정수2 = NV큰정수(11)
	v큰정수3, 에러 := v큰정수1.S나누기(v큰정수1, v큰정수2)
	
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v큰정수3.G값(), big.NewInt(10))

	v큰정수1 = NV큰정수(110)
	v큰정수2 = NV큰정수(0)
	v큰정수3, 에러 = v큰정수1.S나누기(v큰정수1, v큰정수2)
	
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v큰정수3 == nil, "")
	
	// S반대부호값() 테스트
	v큰정수1 = NV큰정수(100.0)
	v큰정수2 = NV큰정수(-100.0)
	
	F같은값_확인(테스트, v큰정수1.S반대부호값(v큰정수1).G값(), big.NewInt(-100))
	F같은값_확인(테스트, v큰정수2.S반대부호값(v큰정수2).G값(), big.NewInt(100))
	
	// S셀프_절대값() 테스트
	v큰정수1 = NV큰정수(-1000)
	v큰정수2 = NV큰정수(1000)
	
	F같은값_확인(테스트, v큰정수1.S셀프_절대값().G값(), big.NewInt(1000))
	F같은값_확인(테스트, v큰정수1.S셀프_절대값().G값(), big.NewInt(1000))
	
	// S셀프_더하기() 테스트
	v큰정수1 = NV큰정수(100)
	v큰정수2 = NV큰정수(1000)
	
	F같은값_확인(테스트, v큰정수1.S셀프_더하기(v큰정수2).G값(), big.NewInt(1100))
	
	// S셀프_빼기() 테스트
	v큰정수1 = NV큰정수(100)
	v큰정수2 = NV큰정수(1000)
	
	F같은값_확인(테스트, v큰정수1.S셀프_빼기(v큰정수2).G값(), big.NewInt(-900))
	
	// S셀프_곱하기() 테스트
	v큰정수1 = NV큰정수(10)
	v큰정수2 = NV큰정수(4)
	
	F같은값_확인(테스트, v큰정수1.S셀프_곱하기(v큰정수2).G값(), big.NewInt(40))
	
	// S셀프_나누기() 테스트
	v큰정수1 = NV큰정수(1000)
	v큰정수2 = NV큰정수(-100)
	
	v큰정수1, 에러 = v큰정수1.S셀프_나누기(v큰정수2)
	
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v큰정수1, big.NewInt(-10))
	
	v큰정수1 = NV큰정수(1000)
	v큰정수2 = NV큰정수(0)
	
	v큰정수1, 에러 = v큰정수1.S셀프_나누기(v큰정수2)
	
	F에러발생_확인(테스트, 에러)
	F같은값_확인(테스트, v큰정수1, nil)
	
	// S셀프_반대부호값() 테스트
	v큰정수1 = NV큰정수(10)
	v큰정수2 = NV큰정수(-10)
	
	F같은값_확인(테스트, v큰정수1.S셀프_반대부호값().G값(), big.NewInt(-10))
	F같은값_확인(테스트, v큰정수2.S셀프_반대부호값().G값(), big.NewInt(10))
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v큰정수.(type) {
	case I변수형, V큰정수:
		// OK
	case I상수형, C큰정수:
		테스트.Error("common.TestV큰정수() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV큰정수() : switch v큰정수.(type) 예상치 못한 경우.")
	}
	
	switch c큰정수.(type) {
	case I상수형, C큰정수:
		// OK
	case I변수형, V큰정수:
		테스트.Error("common.TestV큰정수() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV큰정수() : switch c큰정수.(type) 예상치 못한 경우.")
	}
}