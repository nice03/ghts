package common

import (
	"math/big"
	"math/rand"
	"reflect"
	"strings"
	"testing"
	"time"
)

func TestC정수(테스트 *testing.T) {
	초기값 := int64(10)
	예상값 := int64(10)

	// 생성자 테스트
	var c정수 C정수 = NC정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	정수값 := c정수.G값()
	정수값 = 정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c정수.G값(), 예상값)

	switch c정수.(type) {
	case I변수형:
		테스트.Error("common.TestC정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC부호없는_정수(테스트 *testing.T) {
	초기값 := uint64(10)
	예상값 := uint64(10)

	// 생성자 테스트
	var c부호없는_정수 C부호없는_정수 = NC부호없는_정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	부호없는_정수값 := c부호없는_정수.G값()
	부호없는_정수값 = 부호없는_정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)
	
	switch c부호없는_정수.(type) {
	case I변수형:
		테스트.Error("common.TestC부호없는_정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC실수(테스트 *testing.T) {
	초기값 := float64(10.0)
	예상값 := float64(10.0)

	// 생성자 테스트
	var c실수 C실수 = NC실수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c실수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c실수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	실수값 := c실수.G값()
	실수값 = 실수값 + 10.0 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c실수.G값(), 예상값)

	switch c실수.(type) {
	case I변수형:
		테스트.Error("common.TestC실수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC문자열(테스트 *testing.T) {
	초기값 := "테스트 문자열"
	예상값 := "테스트 문자열"

	// 생성자 테스트
	var c문자열 C문자열 = NC문자열(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + "추가 문자열"

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	문자열값 := c문자열.G값()
	문자열값 = 문자열값 + "추가 문자열" // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	switch c문자열.(type) {
	case I변수형:
		테스트.Error("common.TestC문자열() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC참거짓(테스트 *testing.T) {
	초기값 := true
	예상값 := true

	// 생성자 테스트
	var c참거짓 C참거짓 = NC참거짓(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = !초기값

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	참거짓값 := c참거짓.G값()
	참거짓값 = !참거짓값 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	switch c참거짓.(type) {
	case I변수형:
		테스트.Error("common.TestC참거짓() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func testI시점(테스트 *testing.T, 생성자 interface{}) {
	입력값, _ := F문자열2일자("2000-01-01")
	입력값_백업, _ := F문자열2일자("2000-01-01")
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var 시점 I시점

	// 생성자 테스트
	switch 생성자.(type) {
	case func(time.Time) C시점:
		생성자_ := 생성자.(func(time.Time) C시점)
		시점 = 생성자_(입력값)
	case func(time.Time) V시점:
		생성자_ := 생성자.(func(time.Time) V시점)
		시점 = 생성자_(입력값)
	default:
		panic("testI시점() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 시점.G값(), 입력값)
	
	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값.AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 시점.G값(), 입력값)
	F같은값_확인(테스트, 시점.G값(), 입력값_백업)
	
	// 출력값 변경 후 독립성 확인.
	출력값 := 시점.G값()
	출력값_백업 := F시점_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)
	
	출력값 = 출력값.AddDate(0, 0, 1)
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 시점.G값())
	F같은값_확인(테스트, 출력값_백업, 시점.G값())
}

func TestC시점(테스트 *testing.T) {
	testI시점(테스트, NC시점)

	일자, _ := F문자열2일자("2000-01-01")
	c시점 := NC시점(일자)
	
	switch c시점.(type) {
	case I변수형, V시점:
		테스트.Error("common.TestC시점() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV시점(테스트 *testing.T) {
	testI시점(테스트, NV시점)

	입력값, _ := F문자열2일자("2000-01-01")
	입력값_백업, _ := F문자열2일자("2000-01-01")

	var v시점 V시점 = NV시점(입력값)
	var c시점 C시점 = v시점.G상수형()

	// G상수형() 테스트
	F같은값_확인(테스트, c시점.G값(), 입력값_백업)

	// S값() 테스트. 
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := F시점_복사(입력값).AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 입력값, 바뀐값)

	v시점.S값(바뀐값)

	F같은값_확인(테스트, v시점.G값(), 바뀐값)
	F같은값_확인(테스트, c시점.G값(), 입력값)
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v시점.(type) {
	case I변수형, V시점:
		// OK
	case I상수형, C시점:
		테스트.Error("common.TestV시점() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch v시점.(type) 예상치 못한 경우.")
	}
	
	switch c시점.(type) {
	case I상수형, C시점:
		// OK
	case I변수형, V시점:
		테스트.Error("common.TestV시점() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch c시점.(type) 예상치 못한 경우.")
	}
}

func testI정밀수(테스트 *testing.T, 생성자 interface{}) {
	입력값, _ := F정밀수(10.0045)
	입력값_백업 := F정밀수_복사(입력값)
	
	실수_입력값, _ := 입력값.Float64()
	실수_입력값_백업 := 실수_입력값	

	var 정밀수 I정밀수

	// 생성자 테스트
	switch 생성자.(type) {
	case func(float64) C정밀수:
		생성자_ := 생성자.(func(float64) C정밀수)
		정밀수 = 생성자_(실수_입력값)
	case func(*big.Rat) C정밀수:
		생성자_ := 생성자.(func(*big.Rat) C정밀수)
		정밀수 = 생성자_(입력값)
	case func(float64) V정밀수:
		생성자_ := 생성자.(func(float64) V정밀수)
		정밀수 = 생성자_(실수_입력값)
	case func(*big.Rat) V정밀수:
		생성자_ := 생성자.(func(*big.Rat) V정밀수)
		정밀수 = 생성자_(입력값)
	case func(*sC정밀수) V정밀수:	// sC정밀수.G변수형() 메소드
		생성자_ := 생성자.(func(*sC정밀수) V정밀수)
		정밀수 = 생성자_(&sC정밀수{&s정밀수{입력값}})
	case func(*sV정밀수) C정밀수:	// sV정밀수.G상수형() 메소드
		생성자_ := 생성자.(func(*sV정밀수) C정밀수)
		정밀수 = 생성자_(&sV정밀수{&s정밀수{입력값}})
	default:
		테스트.Errorf("%stestI정밀수() : 알려지지 않은  생성자 타입 %v.", 
						F소스코드_위치(2), 
						reflect.TypeOf(생성자))
	}

	// G값() 테스트
	F같은값_확인(테스트, 정밀수, 입력값)
	
	// G실수값() 테스트
	F같은값_확인(테스트, 정밀수.G실수(), 실수_입력값)
	
	// G반올림_실수() 테스트
	F같은값_확인(테스트, 정밀수.G반올림_실수(2), 10.0)
	F같은값_확인(테스트, 정밀수.G반올림_실수(3), 10.005)
	
	// G반올림_정밀수() 테스트
	F같은값_확인(테스트, 정밀수.G반올림_정밀수(2), 10.0)
	F같은값_확인(테스트, 정밀수.G반올림_정밀수(3), 10.005)
	
	// G반올림_문자열() 테스트
	F같은값_확인(테스트, 정밀수.G반올림_문자열(2), "10.00")
	F같은값_확인(테스트, 정밀수.G반올림_문자열(3), "10.005")

	// G문자열() 및 String() 테스트
	F같은값_확인(테스트, 정밀수.(I기본_문자열).String(), "10.0045")
	
	// G부호() 테스트
//	if 양수값.G부호() != 1 ||
//		음수값.G부호() != -1 ||
//		제로값.G부호() != 0 {
//		테스트.Errorf("common.TestI정밀수() : G부호() 불일치. 양수값 1 %v, 음수값 -1 %v, 제로값 0 %v.", 
//						양수값.G부호(), 음수값.G부호(), 제로값.G부호())
//	}
	
	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100,1))	// 입력값 변수를 변경
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 정밀수, 입력값)
	F같은값_확인(테스트, 정밀수, 입력값_백업)
	
	F같은값_확인(테스트, 실수_입력값, 실수_입력값_백업)
	
	실수_입력값 = 실수_입력값 + 100	// 입력값 변수를 변경
	
	F다른값_확인(테스트, 실수_입력값, 입력값_백업)
	F다른값_확인(테스트, 정밀수, 실수_입력값)
	F같은값_확인(테스트, 정밀수, 실수_입력값_백업)

	// G값()으로 읽어온 값을 변경한 후에도 독립성이 유지되는 지 확인.
	읽어온_값 := 정밀수.G값()
	
	F같은값_확인(테스트, 읽어온_값, 입력값_백업)
	
	읽어온_값.Add(읽어온_값, big.NewRat(100, 1)) // G값()으로 읽어온 변수를 변경.
	
	F다른값_확인(테스트, 읽어온_값, 입력값_백업)
	F다른값_확인(테스트, 읽어온_값, 정밀수)
	F같은값_확인(테스트, 정밀수, 입력값_백업)
}

func TestC정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NC정밀수)
	
	// G변수형() 테스트
	c정밀수 := NC정밀수(0.0)
	testI정밀수(테스트, (*sC정밀수).G변수형)
	
	// 상수형은 변수형으로 변환되면 안 된다.
	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NV정밀수)
	
	var v정밀수 V정밀수 = NV정밀수(100)
	var c정밀수 C정밀수 = v정밀수.G상수형()
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v정밀수.(type) {
	case I변수형, V정밀수:
		// OK
	case I상수형, C정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 제대로 판정되지 않음. 타입 %v", 
						F소스코드_위치(1), reflect.TypeOf(v정밀수))
	}
	
	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 제대로 판정되지 않을 수 있음.", F소스코드_위치(1))
	}
	
	// G상수형() 테스트
	testI정밀수(테스트, (*sV정밀수).G상수형)
	
	// 테스트 준비.
	입력값 := big.NewRat(100045, 10000)
	입력값_백업 := F정밀수_복사(입력값)

	v정밀수 = NV정밀수Big(입력값)
	c정밀수 = v정밀수.G상수형()
	
	// S값() 실행 후 변수형 값은 변경되고, G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100, 1))
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	
	v정밀수.S값Big(입력값)
	
	F같은값_확인(테스트, v정밀수, 입력값)	// v정밀수 값은 바뀌어야 함.
	F같은값_확인(테스트, c정밀수, 입력값_백업)	// c정밀수 값은 그대로 이어야 함.
	
	// 연산함수 테스트
	F같은값_확인(테스트, NV정밀수(-100).S절대값(), 100)
	F같은값_확인(테스트, NV정밀수(100).S절대값(), 100)
	
	F같은값_확인(테스트, NV정밀수(100).S더하기(c정밀수1), 200)
	F같은값_확인(테스트, NV정밀수(100).S빼기(c정밀수1), 0)
	F같은값_확인(테스트, NV정밀수(100).S곱하기(c정밀수1), 10000)
	
	v정밀수, 에러 = NV정밀수(100).S나누기(NC정밀수(10))
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, 10)
	
	v정밀수, 에러 = NV정밀수(100).S나누기(NC정밀수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	v정밀수, 에러 = NV정밀수(100).S역수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, 0.01)
	
	v정밀수, 에러 = NV정밀수(0).S역수()
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	F같은값_확인(테스트, NV정밀수(100).S반대부호값(), -100)
	F같은값_확인(테스트, NV정밀수(-100).S반대부호값(), 100)
	
	// 연산 함수 테스트.
	c정밀수1 := NC정밀수(100.0)
	c정밀수2 := NC정밀수(-100.0)
	
	F같은값_확인(테스트, v정밀수.S절대값2(c정밀수1), 100)
	F같은값_확인(테스트, v정밀수.S절대값2(c정밀수2), 100)
	
	F같은값_확인(테스트, v정밀수.S더하기2(c정밀수1, c정밀수2), 0)
	F같은값_확인(테스트, v정밀수.S빼기2(c정밀수1, c정밀수2), 200)
	F같은값_확인(테스트, v정밀수.S곱하기2(c정밀수1, c정밀수2), -10000)
	
	v정밀수, 에러 := v정밀수.S나누기2(c정밀수1, c정밀수2)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, -1)
	
	v정밀수, 에러 = v정밀수.S나누기2(c정밀수1, NC정밀수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	v정밀수 = NV정밀수(0)
	v정밀수, 에러 = v정밀수.S역수2(c정밀수1)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, 0.01)
	
	v정밀수, 에러 = v정밀수.S역수2(NC정밀수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	v정밀수 = NV정밀수(0)
	F같은값_확인(테스트, v정밀수.S반대부호값2(c정밀수1), -100)
	F같은값_확인(테스트, v정밀수.S반대부호값2(c정밀수2), 100)
	
	
}

func testI통화(테스트 *testing.T, 생성자 interface{}) {	
	// 통화종류를 임의로 선택하기.
	통화종류_모음 := []P통화{KRW, USD, CNY, EUR}
	통화종류 := 통화종류_모음[rand.Int31n(int32(len(통화종류_모음) - 1))]
	
	초기값 := big.NewRat(111111111, 10000)
	실수_초기값 := F정밀수2실수(초기값)
	
	var 통화 I통화
	
	// 생성자 테스트
	switch 생성자.(type) {
	case func(P통화, float64) C통화:
		생성자_ := 생성자.(func(P통화, float64) C통화)
		통화 = 생성자_(통화종류, 실수_초기값)
	case func(P통화, *big.Rat) C통화:
		생성자_ := 생성자.(func(P통화, *big.Rat) C통화)
		통화 = 생성자_(통화종류, 초기값)
	case func(P통화, float64) V통화:
		생성자_ := 생성자.(func(P통화, float64) V통화)
		통화 = 생성자_(통화종류, 실수_초기값)
	case func(P통화, *big.Rat) V통화:
		생성자_ := 생성자.(func(P통화, *big.Rat) V통화)
		통화 = 생성자_(통화종류, 초기값)
	case func(float64) C통화:
		생성자_ := 생성자.(func(float64) C통화)
		통화 = 생성자_(실수_초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(*big.Rat) C통화:
		생성자_ := 생성자.(func(*big.Rat) C통화)
		통화 = 생성자_(초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(float64) V통화:
		생성자_ := 생성자.(func(float64) V통화)
		통화 = 생성자_(실수_초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(*big.Rat) V통화:
		생성자_ := 생성자.(func(*big.Rat) V통화)
		통화 = 생성자_(초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(*sC통화) V통화:	// sC통화.G변수형() 메소드
		생성자_ := 생성자.(func(*sC통화) V통화)
		통화 = 생성자_(&sC통화{통화종류, NC정밀수Big(초기값)})
	case func(*sV통화) C통화:	// sV통화.G상수형() 메소드
		생성자_ := 생성자.(func(*sV통화) C통화)
		통화 = 생성자_(&sV통화{통화종류, NV정밀수Big(초기값)})
	default:
		테스트.Errorf("%stestI통화() : 알려지지 않은  생성자 타입 %v.", 
						F소스코드_위치(2), 
						reflect.TypeOf(생성자))
	}
	
	입력값 := F정밀수_반올림값Big(초기값, F통화종류별_정밀도(통화종류))
	입력값_백업 := F정밀수_복사(입력값)
	
	실수_입력값 := F정밀수2실수(입력값)
	실수_입력값_백업 := F정밀수2실수(입력값)
	
	// String() 테스트
	문자열 := 통화.(I기본_문자열).String()
	if F통화종류별_정밀도(통화종류) == 0 {			
		F같은값_확인(테스트, 문자열, 	string(통화종류) + " " + "11,111")
	} else {
		F참인지_확인(테스트, strings.HasPrefix(문자열, 
								string(통화종류) + " " + "11,111."),
								"통화.String() %v", 문자열)
	}
	
	// 통화 그 자체로 비교되는 지 확인
	F같은값_확인(테스트, 통화, NC통화Big(통화종류, 입력값))
	
	// G종류() 테스트
	F같은값_확인(테스트, 통화.G종류(), 통화종류)

	// G값() 테스트
	F같은값_확인(테스트, 통화.G값(), 입력값)
	
	// G부호() 테스트
//	if 양수값.G부호() != 1 ||
//		음수값.G부호() != -1 ||
//		제로값.G부호() != 0 {
//		테스트.Errorf("common.TestI통화() : G부호() 불일치. 양수값 1 %v, 음수값 -1 %v, 제로값 0 %v.", 
//						양수값.G부호(), 음수값.G부호(), 제로값.G부호())
//	}
	
	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	F같은값_확인(테스트, 실수_입력값, 실수_입력값_백업)
	
	// 입력값 변수를 변경
	입력값.Add(입력값, big.NewRat(100,1))	
	실수_입력값 = 실수_입력값 + 100.0
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 실수_입력값, 실수_입력값_백업)
	
	F다른값_확인(테스트, 통화.G값(), 입력값)
	F다른값_확인(테스트, 통화.G값(), 실수_입력값)
	
	F같은값_확인(테스트, 통화.G값(), 입력값_백업)
	F같은값_확인(테스트, 통화.G값(), 실수_입력값_백업)
	
	// G값()으로 읽어온 값을 변경한 후에도 독립성이 유지되는 지 확인.
	읽어온_값 := 통화.G값()
	
	F같은값_확인(테스트, 읽어온_값, 입력값_백업)
	
	switch 읽어온_값.(type) {
	case V정밀수:
		읽어온_값.(V정밀수).S셀프_더하기(NC정밀수(100)) // G값()으로 읽어온 변수를 변경.
		
		F다른값_확인(테스트, 읽어온_값, 입력값_백업)
		F다른값_확인(테스트, 통화.G정밀수(), 읽어온_값.G정밀수())
		F같은값_확인(테스트, 통화.G정밀수(), 입력값_백업)
	}
}

func TestC통화(테스트 *testing.T) {
	testI통화(테스트, NC통화)
	testI통화(테스트, NC통화Big)
	testI통화(테스트, (*sC통화).G변수형)

	// 상수형은 변수형으로 변환되면 안 된다.
	c통화 := NC통화(KRW, 0.0)
	
	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV통화(테스트 *testing.T) {
	testI통화(테스트, NV통화)
	testI통화(테스트, NV통화Big)
	testI통화(테스트, (*sV통화).G상수형)
	
	// 통화종류를 매번 다르게 선택하기.
	통화종류_모음 := []P통화{KRW, USD, CNY, EUR}
	통화종류 := 통화종류_모음[rand.Int31n(int32(len(통화종류_모음) - 1))]
	
	초기값 := big.NewRat(11111111, 100000)
	
	입력값 := F정밀수_반올림값Big(초기값, F통화종류별_정밀도(통화종류))
	입력값_백업 := F정밀수_복사(입력값)
	
	v통화 := NV통화Big(통화종류, 초기값)
	c통화 := v통화.G상수형()	
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v통화.(type) {
	case I변수형, V통화:
		// OK
	case I상수형, C통화:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
	
	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
	
	// S값() 실행 후 변수형 값은 변경되고, 
	// G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100, 1))
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	
	v통화.S값Big(입력값)
	
	F같은값_확인(테스트, v통화.G값(), 입력값)
	F같은값_확인(테스트, c통화.G값(), 입력값_백업)
	
	// 셀프 연산함수 테스트
	F같은값_확인(테스트, NV통화(통화종류, -100).S절대값().G값(), 100)
	F같은값_확인(테스트, NV통화(통화종류, 100).S절대값().G값(), 100)
	
	F같은값_확인(테스트, NV통화(통화종류, 100).S더하기(c통화1).G값(), 200)
	F같은값_확인(테스트, NV통화(통화종류, 100).S빼기(c통화1).G값(), 0)
	F같은값_확인(테스트, NV통화(통화종류, 100).S곱하기(c통화1).G값(), 10000)
	
	v통화, 에러 = NV통화(통화종류, 100).S나누기(NC통화(통화종류, 10))
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v통화.G값(), 10)
	
	v통화, 에러 = NV통화(통화종류, 100).S나누기(NC통화(통화종류, 0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v통화 == nil)
	
	F같은값_확인(테스트, NV통화(통화종류, 100).S반대부호값().G값(), -100)
	F같은값_확인(테스트, NV통화(통화종류, -100).S반대부호값().G값(), 100)
	
	// 연산 함수 테스트.
	c통화1 := NC통화(통화종류, 100.0)
	c통화2 := NC통화(통화종류, -100.0)
	
	
	F같은값_확인(테스트, v통화.S절대값2(c통화1), NC통화(통화종류, 100))
	F같은값_확인(테스트, v통화.S절대값2(c통화2), NC통화(통화종류, 100))
	
	F같은값_확인(테스트, v통화.S더하기2(c통화1, c통화2), NC통화(통화종류, 0))
	F같은값_확인(테스트, v통화.S빼기2(c통화1, c통화2), NC통화(통화종류, 200))
	F같은값_확인(테스트, v통화.S곱하기2(c통화1, c통화2), NC통화(통화종류, -10000))
	
	v통화, 에러 := v통화.S나누기2(c통화1, c통화2)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v통화, NC통화(통화종류, -1))
	
	v통화, 에러 = v통화.S나누기2(c통화1, NC통화(통화종류, 0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v통화 == nil)
	
	v통화 = NV통화(통화종류, 0)
	F같은값_확인(테스트, v통화.S반대부호값2(c통화1).G값(), -100)
	F같은값_확인(테스트, v통화.S반대부호값2(c통화2).G값(), 100)
}

func TestC복합_상수형(테스트 *testing.T) {
	// 참거짓
	c참거짓 := NC복합_상수형(NC참거짓(true))
	F같은값_확인(테스트, c참거짓.G형식명(), "*common.sC참거짓")
	F같은값_확인(테스트, c참거짓.G값().(C참거짓).G값(), true)
	
	참거짓, 에러 := c참거짓.G참거짓()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 참거짓, true)
	
	// 정수
	c정수 := NC복합_상수형(NC정수(100))
	F같은값_확인(테스트, c정수.G형식명(), "*common.sC정수")
	F같은값_확인(테스트, c정수.G값().(C정수).G값(), 100)
	
	정수, 에러 := c정수.G정수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 정수, 100)
	
	// 부호없는_정수
	c부호없는_정수 := NC복합_상수형(NC부호없는_정수(100))
	F같은값_확인(테스트, c부호없는_정수.G형식명(), "*common.sC부호없는_정수")
	F같은값_확인(테스트, c부호없는_정수.G값().(C부호없는_정수).G값(), 100)
	
	부호없는_정수, 에러 := c부호없는_정수.G부호없는_정수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 부호없는_정수, 100)
	
	// 실수
	c실수 := NC복합_상수형(NC실수(100.123))
	F같은값_확인(테스트, c실수.G형식명(), "*common.sC실수")
	F같은값_확인(테스트, c실수.G값().(C실수).G값(), 100)
	
	실수, 에러 := c실수.G실수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 실수, 100)
	
	// 문자열
	c문자열 := NC복합_상수형(NC문자열("테스트"))
	F같은값_확인(테스트, c문자열.G형식명(), "*common.sC문자열")
	F같은값_확인(테스트, c문자열.G값().(C문자열).G값(), "테스트")
	
	문자열, 에러 := c문자열.G문자열()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 문자열, "테스트")
	
	// 시점
	시점_입력값 := time.Now(); c시점 := NC복합_상수형(NC시점(시점_입력값))
	F같은값_확인(테스트, c시점.G형식명(), "*common.sC시점")
	F같은값_확인(테스트, c시점.G값().(C시점).G값(), 시점_입력값)
	
	시점_출력값, 에러 := c시점.G시점()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 시점_입력값, 시점_출력값)
	
	// 정밀수
	정밀수_입력값 := big.NewRat(100123, 1000)
	c정밀수 := NC복합_상수형(NC정밀수(정밀수_입력값))
	F같은값_확인(테스트, c정밀수.G형식명(), "*common.sC정밀수")
	F같은값_확인(테스트, c정밀수.G값().(C정밀수).G값(), 정밀수_입력값)
	
	정밀수_출력값, 에러 := c정밀수.G정밀수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 정밀수_입력값, 정밀수_출력값)
	
	// 통화
	통화종류_모음 := []P통화{KRW, USD, CNY, EUR}
	통화종류 := 통화종류_모음[rand.Int31n(int32(len(통화종류_모음) - 1))]
	통화_금액 := F정밀수_반올림값Big(정밀수_입력값, F통화종류별_정밀도(통화종류))
	c통화 := NC복합_상수형(NC통화Big(통화종류, 정밀수_입력값))
	F같은값_확인(테스트, c통화.G형식명(), "*common.sC통화")
	F같은값_확인(테스트, c통화.G값().(C통화).G종류(), 통화종류)
	F같은값_확인(테스트, c통화.G값().(C통화).G값(), 통화_금액)
	
	통화_출력값, 에러 := c통화.G통화()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 통화종류, 통화_출력값.G종류())
	F같은값_확인(테스트, 통화_금액, 통화_출력값.G값())
}