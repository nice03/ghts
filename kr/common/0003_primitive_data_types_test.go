package common

import (
	"math/big"
	"reflect"
	"testing"
	"time"
)

func TestC정수(테스트 *testing.T) {
	초기값 := int64(10)
	예상값 := int64(10)

	// 생성자 테스트
	var c정수 C정수 = NC정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	정수값 := c정수.G값()
	정수값 = 정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c정수.G값(), 예상값)

	switch c정수.(type) {
	case I변수형:
		테스트.Error("common.TestC정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC부호없는_정수(테스트 *testing.T) {
	초기값 := uint64(10)
	예상값 := uint64(10)

	// 생성자 테스트
	var c부호없는_정수 C부호없는_정수 = NC부호없는_정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	부호없는_정수값 := c부호없는_정수.G값()
	부호없는_정수값 = 부호없는_정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)
	
	switch c부호없는_정수.(type) {
	case I변수형:
		테스트.Error("common.TestC부호없는_정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC실수(테스트 *testing.T) {
	초기값 := float64(10.0)
	예상값 := float64(10.0)

	// 생성자 테스트
	var c실수 C실수 = NC실수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c실수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c실수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	실수값 := c실수.G값()
	실수값 = 실수값 + 10.0 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c실수.G값(), 예상값)

	switch c실수.(type) {
	case I변수형:
		테스트.Error("common.TestC실수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC문자열(테스트 *testing.T) {
	초기값 := "테스트 문자열"
	예상값 := "테스트 문자열"

	// 생성자 테스트
	var c문자열 C문자열 = NC문자열(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + "추가 문자열"

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	문자열값 := c문자열.G값()
	문자열값 = 문자열값 + "추가 문자열" // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	switch c문자열.(type) {
	case I변수형:
		테스트.Error("common.TestC문자열() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC참거짓(테스트 *testing.T) {
	초기값 := true
	예상값 := true

	// 생성자 테스트
	var c참거짓 C참거짓 = NC참거짓(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = !초기값

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	참거짓값 := c참거짓.G값()
	참거짓값 = !참거짓값 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	switch c참거짓.(type) {
	case I변수형:
		테스트.Error("common.TestC참거짓() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func testI시점(테스트 *testing.T, 생성자 interface{}) {
	입력값, _ := F문자열2일자("2000-01-01")
	입력값_백업, _ := F문자열2일자("2000-01-01")
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var 시점 I시점

	// 생성자 테스트
	switch 생성자.(type) {
	case func(time.Time) C시점:
		생성자_ := 생성자.(func(time.Time) C시점)
		시점 = 생성자_(입력값)
	case func(time.Time) V시점:
		생성자_ := 생성자.(func(time.Time) V시점)
		시점 = 생성자_(입력값)
	default:
		panic("testI시점() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 시점.G값(), 입력값)
	
	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값.AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 시점.G값(), 입력값)
	F같은값_확인(테스트, 시점.G값(), 입력값_백업)
	
	// 출력값 변경 후 독립성 확인.
	출력값 := 시점.G값()
	출력값_백업 := F시점_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)
	
	출력값 = 출력값.AddDate(0, 0, 1)
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 시점.G값())
	F같은값_확인(테스트, 출력값_백업, 시점.G값())
}

func TestC시점(테스트 *testing.T) {
	testI시점(테스트, NC시점)

	일자, _ := F문자열2일자("2000-01-01")
	c시점 := NC시점(일자)
	
	switch c시점.(type) {
	case I변수형, V시점:
		테스트.Error("common.TestC시점() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV시점(테스트 *testing.T) {
	testI시점(테스트, NV시점)

	입력값, _ := F문자열2일자("2000-01-01")
	입력값_백업, _ := F문자열2일자("2000-01-01")

	var v시점 V시점 = NV시점(입력값)
	var c시점 C시점 = v시점.G상수형()

	// G상수형() 테스트
	F같은값_확인(테스트, c시점.G값(), 입력값_백업)

	// S값() 테스트. 
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := F시점_복사(입력값).AddDate(0, 0, 1)
	
	F다른값_확인(테스트, 입력값, 바뀐값)

	v시점.S값(바뀐값)

	F같은값_확인(테스트, v시점.G값(), 바뀐값)
	F같은값_확인(테스트, c시점.G값(), 입력값)
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v시점.(type) {
	case I변수형, V시점:
		// OK
	case I상수형, C시점:
		테스트.Error("common.TestV시점() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch v시점.(type) 예상치 못한 경우.")
	}
	
	switch c시점.(type) {
	case I상수형, C시점:
		// OK
	case I변수형, V시점:
		테스트.Error("common.TestV시점() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch c시점.(type) 예상치 못한 경우.")
	}
}

func testI큰정수(테스트 *testing.T, 생성자 interface{}) {
	정수_입력값 := int64(100)
	정수_입력값_백업 := int64(100)
	F같은값_확인(테스트, 정수_입력값, 정수_입력값_백업)
	
	큰정수_입력값 := big.NewInt(정수_입력값)
	큰정수_입력값_백업 := big.NewInt(정수_입력값_백업)
	F같은값_확인(테스트, 큰정수_입력값, 큰정수_입력값_백업)

	var 큰정수 I큰정수

	// 생성자 테스트
	switch 생성자.(type) {
	case func(int64) C큰정수:
		생성자_ := 생성자.(func(int64) C큰정수)
		큰정수 = 생성자_(정수_입력값)
	case func(*big.Int) C큰정수:
		생성자_ := 생성자.(func(*big.Int) C큰정수)
		큰정수 = 생성자_(큰정수_입력값)
	case func(int64) V큰정수:
		생성자_ := 생성자.(func(int64) V큰정수)
		큰정수 = 생성자_(정수_입력값)
	case func(*big.Int) V큰정수:
		생성자_ := 생성자.(func(*big.Int) V큰정수)
		큰정수 = 생성자_(큰정수_입력값)
	default:
		panic("testI큰정수() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 큰정수.G값(), 큰정수_입력값)
	
	// 입력값 변경 후 독립성 확인.
	정수_입력값++
	큰정수_입력값.Add(큰정수_입력값, big.NewInt(10))
	
	F다른값_확인(테스트, 정수_입력값, 정수_입력값_백업)
	F다른값_확인(테스트, 큰정수_입력값, 큰정수_입력값_백업)
	
	F다른값_확인(테스트, 큰정수.G값(), 큰정수_입력값)
	F같은값_확인(테스트, 큰정수.G값(), 큰정수_입력값_백업)
	
	// 출력값 변경 후 독립성 확인.
	출력값 := 큰정수.G값()
	출력값_백업 := F큰정수_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)
	
	출력값.Add(출력값, big.NewInt(10))
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 큰정수.G값())
	F같은값_확인(테스트, 출력값_백업, 큰정수.G값())
}

func TestC큰정수(테스트 *testing.T) {
	testI큰정수(테스트, NC큰정수)

	c큰정수 := NC큰정수(1)
	
	switch c큰정수.(type) {
	case I변수형, V큰정수:
		테스트.Error("common.TestC큰정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV큰정수(테스트 *testing.T) {
	testI큰정수(테스트, NV큰정수)

	입력값 := big.NewInt(100)
	입력값_백업 := big.NewInt(100)
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var v큰정수 V큰정수 = NV큰정수Big(입력값)
	var c큰정수 C큰정수 = v큰정수.G상수형()
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v큰정수.(type) {
	case I변수형, V큰정수:
		// OK
	case I상수형, C큰정수:
		테스트.Error("common.TestV큰정수() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV큰정수() : switch v큰정수.(type) 예상치 못한 경우.")
	}
	
	switch c큰정수.(type) {
	case I상수형, C큰정수:
		// OK
	case I변수형, V큰정수:
		테스트.Error("common.TestV큰정수() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV큰정수() : switch c큰정수.(type) 예상치 못한 경우.")
	}

	// G상수형() 테스트
	F같은값_확인(테스트, c큰정수.G값(), 입력값)

	// S값() 테스트. 
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := 입력값.Add(입력값, big.NewInt(10))
	
	F다른값_확인(테스트, 바뀐값, 입력값_백업)

	v큰정수.S값Big(바뀐값)

	F같은값_확인(테스트, v큰정수.G값(), 바뀐값)
	F같은값_확인(테스트, c큰정수.G값(), 입력값_백업)
	
	// 연산 함수 테스트.
	c큰정수1 := NC큰정수(100)
	c큰정수2 := NC큰정수(-100)
	
	F같은값_확인(테스트, v큰정수.S절대값(c큰정수1), 100)
	F같은값_확인(테스트, v큰정수.S절대값(c큰정수2), 100)
	
	F같은값_확인(테스트, v큰정수.S더하기(c큰정수1, c큰정수2), 0)
	F같은값_확인(테스트, v큰정수.S빼기(c큰정수1, c큰정수2), 200)
	F같은값_확인(테스트, v큰정수.S곱하기(c큰정수1, c큰정수2), -10000)
	
	v큰정수, 에러 := v큰정수.S나누기(c큰정수1, c큰정수2)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v큰정수, -1)
	
	v큰정수, 에러 = v큰정수.S나누기(c큰정수1, NC큰정수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v큰정수 == nil)
	
	v큰정수 = NV큰정수(0)
	F같은값_확인(테스트, v큰정수.S반대부호값(c큰정수1), -100)
	F같은값_확인(테스트, v큰정수.S반대부호값(c큰정수2), 100)
	
	// 셀프 연산함수 테스트
	F같은값_확인(테스트, NV큰정수(-100).S셀프_절대값(), 100)
	F같은값_확인(테스트, NV큰정수(100).S셀프_절대값(), 100)
	
	F같은값_확인(테스트, NV큰정수(100).S셀프_더하기(c큰정수1), 200)
	F같은값_확인(테스트, NV큰정수(100).S셀프_빼기(c큰정수1), 0)
	F같은값_확인(테스트, NV큰정수(100).S셀프_곱하기(c큰정수1), 10000)
	
	v큰정수, 에러 = NV큰정수(100).S셀프_나누기(NC큰정수(10))
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v큰정수, 10)
	
	v큰정수, 에러 = NV큰정수(100).S셀프_나누기(NC큰정수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v큰정수 == nil)

	F같은값_확인(테스트, NV큰정수(100).S셀프_반대부호값(), -100)
	F같은값_확인(테스트, NV큰정수(-100).S셀프_반대부호값(), 100)
}

func testI정밀수(테스트 *testing.T, 생성자 interface{}) {
	입력값, _ := F정밀수(10.0045)
	입력값_백업 := F정밀수_복사(입력값)
	
	실수_입력값, _ := 입력값.Float64()
	실수_입력값_백업 := 실수_입력값	

	var 정밀수 I정밀수

	// 생성자 테스트
	switch 생성자.(type) {
	case func(float64) C정밀수:
		생성자_ := 생성자.(func(float64) C정밀수)
		정밀수 = 생성자_(실수_입력값)
	case func(*big.Rat) C정밀수:
		생성자_ := 생성자.(func(*big.Rat) C정밀수)
		정밀수 = 생성자_(입력값)
	case func(float64) V정밀수:
		생성자_ := 생성자.(func(float64) V정밀수)
		정밀수 = 생성자_(실수_입력값)
	case func(*big.Rat) V정밀수:
		생성자_ := 생성자.(func(*big.Rat) V정밀수)
		정밀수 = 생성자_(입력값)
	case func(*sV정밀수) C정밀수:	// sV정밀수.G상수형() 메소드
		생성자_ := 생성자.(func(*sV정밀수) C정밀수)
		정밀수 = 생성자_(&sV정밀수{&s정밀수{입력값}})
	default:
		테스트.Errorf("%stestI정밀수() : 알려지지 않은  생성자 타입 %v.", 
						F소스코드_위치(2), 
						reflect.TypeOf(생성자))
	}

	// G값() 테스트
	F같은값_확인(테스트, 정밀수, 입력값)
	
	// G실수값() 테스트
	F같은값_확인(테스트, 정밀수.G실수(), 실수_입력값)
	
	// G반올림_실수() 테스트
	F같은값_확인(테스트, 정밀수.G반올림_실수(2), 10.0)
	F같은값_확인(테스트, 정밀수.G반올림_실수(3), 10.005)
	
	// G반올림_정밀수() 테스트
	F같은값_확인(테스트, 정밀수.G반올림_정밀수(2), 10.0)
	F같은값_확인(테스트, 정밀수.G반올림_정밀수(3), 10.005)
	
	// G반올림_문자열() 테스트
	F같은값_확인(테스트, 정밀수.G반올림_문자열(2), "10.00")
	F같은값_확인(테스트, 정밀수.G반올림_문자열(3), "10.005")

	// G문자열() 및 String() 테스트
	F같은값_확인(테스트, 정밀수.(I기본_문자열).String(), "10.0045")
	
	// G부호() 테스트
//	if 양수값.G부호() != 1 ||
//		음수값.G부호() != -1 ||
//		제로값.G부호() != 0 {
//		테스트.Errorf("common.TestI정밀수() : G부호() 불일치. 양수값 1 %v, 음수값 -1 %v, 제로값 0 %v.", 
//						양수값.G부호(), 음수값.G부호(), 제로값.G부호())
//	}
	
	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100,1))	// 입력값 변수를 변경
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 정밀수, 입력값)
	F같은값_확인(테스트, 정밀수, 입력값_백업)
	
	F같은값_확인(테스트, 실수_입력값, 실수_입력값_백업)
	
	실수_입력값 = 실수_입력값 + 100	// 입력값 변수를 변경
	
	F다른값_확인(테스트, 실수_입력값, 입력값_백업)
	F다른값_확인(테스트, 정밀수, 실수_입력값)
	F같은값_확인(테스트, 정밀수, 실수_입력값_백업)

	// G값()으로 읽어온 값을 변경한 후에도 독립성이 유지되는 지 확인.
	읽어온_값 := 정밀수.G값()
	
	F같은값_확인(테스트, 읽어온_값, 입력값_백업)
	
	읽어온_값.Add(읽어온_값, big.NewRat(100, 1)) // G값()으로 읽어온 변수를 변경.
	
	F다른값_확인(테스트, 읽어온_값, 입력값_백업)
	F다른값_확인(테스트, 읽어온_값, 정밀수)
	F같은값_확인(테스트, 정밀수, 입력값_백업)
}

func TestC정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NC정밀수)

	// 상수형은 변수형으로 변환되면 안 된다.
	c정밀수 := NC정밀수(0.0)
	
	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NV정밀수)
	
	var v정밀수 V정밀수 = NV정밀수(100)
	var c정밀수 C정밀수 = v정밀수.G상수형()
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v정밀수.(type) {
	case I변수형, V정밀수:
		// OK
	case I상수형, C정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 제대로 판정되지 않음. 타입 %v", 
						F소스코드_위치(1), reflect.TypeOf(v정밀수))
	}
	
	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 제대로 판정되지 않을 수 있음.", F소스코드_위치(1))
	}
	
	// G상수형() 테스트
	testI정밀수(테스트, (*sV정밀수).G상수형)
	
	// 테스트 준비.
	입력값 := big.NewRat(100045, 10000)
	입력값_백업 := F정밀수_복사(입력값)

	v정밀수 = NV정밀수Big(입력값)
	c정밀수 = v정밀수.G상수형()
	
	// S값() 실행 후 변수형 값은 변경되고, G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100, 1))
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	
	v정밀수.S값Big(입력값)
	
	F같은값_확인(테스트, v정밀수, 입력값)	// v정밀수 값은 바뀌어야 함.
	F같은값_확인(테스트, c정밀수, 입력값_백업)	// c정밀수 값은 그대로 이어야 함.
	
	// 연산 함수 테스트.
	c정밀수1 := NC정밀수(100.0)
	c정밀수2 := NC정밀수(-100.0)
	
	F같은값_확인(테스트, v정밀수.S절대값(c정밀수1), 100)
	F같은값_확인(테스트, v정밀수.S절대값(c정밀수2), 100)
	
	F같은값_확인(테스트, v정밀수.S더하기(c정밀수1, c정밀수2), 0)
	F같은값_확인(테스트, v정밀수.S빼기(c정밀수1, c정밀수2), 200)
	F같은값_확인(테스트, v정밀수.S곱하기(c정밀수1, c정밀수2), -10000)
	
	v정밀수, 에러 := v정밀수.S나누기(c정밀수1, c정밀수2)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, -1)
	
	v정밀수, 에러 = v정밀수.S나누기(c정밀수1, NC정밀수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	v정밀수 = NV정밀수(0)
	v정밀수, 에러 = v정밀수.S역수(c정밀수1)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, 0.01)
	
	v정밀수, 에러 = v정밀수.S역수(NC정밀수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	v정밀수 = NV정밀수(0)
	F같은값_확인(테스트, v정밀수.S반대부호값(c정밀수1), -100)
	F같은값_확인(테스트, v정밀수.S반대부호값(c정밀수2), 100)
	
	// 셀프 연산함수 테스트
	F같은값_확인(테스트, NV정밀수(-100).S셀프_절대값(), 100)
	F같은값_확인(테스트, NV정밀수(100).S셀프_절대값(), 100)
	
	F같은값_확인(테스트, NV정밀수(100).S셀프_더하기(c정밀수1), 200)
	F같은값_확인(테스트, NV정밀수(100).S셀프_빼기(c정밀수1), 0)
	F같은값_확인(테스트, NV정밀수(100).S셀프_곱하기(c정밀수1), 10000)
	
	v정밀수, 에러 = NV정밀수(100).S셀프_나누기(NC정밀수(10))
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, 10)
	
	v정밀수, 에러 = NV정밀수(100).S셀프_나누기(NC정밀수(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	v정밀수, 에러 = NV정밀수(100).S셀프_역수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v정밀수, 0.01)
	
	v정밀수, 에러 = NV정밀수(0).S셀프_역수()
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v정밀수 == nil)
	
	F같은값_확인(테스트, NV정밀수(100).S셀프_반대부호값(), -100)
	F같은값_확인(테스트, NV정밀수(-100).S셀프_반대부호값(), 100)
}


func testI통화(테스트 *testing.T, 생성자 interface{}) {
	F_TODO("통화 테스트 케이스 코멘트 처리한 것 복원할 것.")
	/*
	fmt.Println(F소스코드_위치(1) + "여기까지")
	
	입력값, _ := F통화(10.0045)
	입력값_백업 := F통화_복사(입력값)
	
	실수_입력값, _ := 입력값.Float64()
	실수_입력값_백업 := 실수_입력값	

	var 통화, 양수값, 음수값, 제로값 I통화

	// 생성자 테스트
	switch 생성자.(type) {
	case func(float64) C통화:
		생성자_ := 생성자.(func(float64) C통화)
		통화 = 생성자_(실수_입력값)
		양수값 = 생성자_(100.0)
		음수값 = 생성자_(-100.0)
		제로값 = 생성자_(0.0)
	case func(*big.Rat) C통화:
		생성자_ := 생성자.(func(*big.Rat) C통화)
		통화 = 생성자_(입력값)
		양수값 = 생성자_(big.NewRat(100, 1))
		음수값 = 생성자_(big.NewRat(-100, 1))
		제로값 = 생성자_(big.NewRat(0, 1))
	case func(float64) V통화:
		생성자_ := 생성자.(func(float64) V통화)
		통화 = 생성자_(실수_입력값)
		양수값 = 생성자_(100.0)
		음수값 = 생성자_(-100.0)
		제로값 = 생성자_(0.0)
	case func(*big.Rat) V통화:
		생성자_ := 생성자.(func(*big.Rat) V통화)
		통화 = 생성자_(입력값)
		양수값 = 생성자_(big.NewRat(100, 1))
		음수값 = 생성자_(big.NewRat(-100, 1))
		제로값 = 생성자_(big.NewRat(0, 1))
	case func(*sV통화) C통화:	// sV통화.G상수형() 메소드
		생성자_ := 생성자.(func(*sV통화) C통화)
		통화 = 생성자_(&sV통화{&s통화{입력값}})
		양수값 = 생성자_(&sV통화{&s통화{big.NewRat(100, 1)}})
		음수값 = 생성자_(&sV통화{&s통화{big.NewRat(-100, 1)}})
	default:
		테스트.Errorf("%stestI통화() : 알려지지 않은  생성자 타입 %v.", 
						F소스코드_위치(2), 
						reflect.TypeOf(생성자))
	}

	// G값() 테스트
	F같은값_확인(테스트, 통화, 입력값)
	
	// G실수값() 테스트
	F같은값_확인(테스트, 통화.G실수값(), 실수_입력값)
	
	// G반올림_실수() 테스트
	F같은값_확인(테스트, 통화.G반올림_실수(2), 10.0)
	F같은값_확인(테스트, 통화.G반올림_실수(3), 10.005)
	
	// G반올림_통화() 테스트
	F같은값_확인(테스트, 통화.G반올림_통화(2), 10.0)
	F같은값_확인(테스트, 통화.G반올림_통화(3), 10.005)
	
	// G반올림_문자열() 테스트
	F같은값_확인(테스트, 통화.G반올림_문자열(2), "10.0")
	F같은값_확인(테스트, 통화.G반올림_문자열(3), "10.005")

	// G문자열() 및 String() 테스트
	F같은값_확인(테스트, 통화.String(), "10.0045")
	
	// G부호() 테스트
//	if 양수값.G부호() != 1 ||
//		음수값.G부호() != -1 ||
//		제로값.G부호() != 0 {
//		테스트.Errorf("common.TestI통화() : G부호() 불일치. 양수값 1 %v, 음수값 -1 %v, 제로값 0 %v.", 
//						양수값.G부호(), 음수값.G부호(), 제로값.G부호())
//	}
	
	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100,1))	// 입력값 변수를 변경
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 통화, 입력값)
	F같은값_확인(테스트, 통화, 입력값_백업)
	
	F같은값_확인(테스트, 실수_입력값, 실수_입력값_백업)
	
	실수_입력값 = 실수_입력값 + 100	// 입력값 변수를 변경
	
	F다른값_확인(테스트, 실수_입력값, 입력값_백업)
	F다른값_확인(테스트, 통화, 실수_입력값)
	F같은값_확인(테스트, 통화, 실수_입력값_백업)

	// G값()으로 읽어온 값을 변경한 후에도 독립성이 유지되는 지 확인.
	읽어온_값 := 통화.G값()
	
	F같은값_확인(테스트, 읽어온_값, 입력값_백업)
	
	읽어온_값.Add(정밀값, big.NewRat(100, 1)) // G값()으로 읽어온 변수를 변경.
	
	F다른값_확인(테스트, 읽어온_값, 입력값_백업)
	F다른값_확인(테스트, 읽어온_값, 통화)
	F같은값_확인(테스트, 통화, 입력값_백업)
}

func TestC통화(테스트 *testing.T) {
	testI통화(테스트, NC통화)

	// 상수형은 변수형으로 변환되면 안 된다.
	c통화 := NC통화(F통화(0.0))
	
	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV통화(테스트 *testing.T) {
	testI통화(테스트, NV통화)
	
	var v통화 V통화
	var c통화 C통화
	
	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v통화.(type) {
	case I변수형, V통화:
		// OK
	case I상수형, C통화:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
	
	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 제대로 판정되지 않을 수 있음.", F소스코드_위치(1))
	}
	
	// G상수형() 테스트
	fmt.Printf("TODO %s TestV통화() : 코멘트 처리한 것 되돌릴 것.")
	//testI통화(테스트, (*sV통화).G상수형)
	
	// 테스트 준비.
	입력값 := big.NewRat(10.0045)
	입력값_백업 := F통화_백업(입력값)

	v통화 = NV통화(입력값)
	c통화 = v통화.G상수형()
	
	// S값() 실행 후 변수형 값은 변경되고, G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)
	
	입력값.Add(입력값, big.NewRat(100, 1))
	
	F다른값_확인(테스트, 입력값, 입력값_백업)
	
	v통화.S값Big(입력값)
	
	F같은값_확인(테스트, v통화, 입력값)	// v통화 값은 바뀌어야 함.
	F같은값_확인(테스트, c통화, 입력값_백업)	// c통화 값은 그대로 이어야 함.
	
	// 연산 함수 테스트.
	c통화1 := NC통화(100.0)
	c통화2 := NC통화(-100.0)
	
	F같은값_확인(테스트, v통화.S절대값(c통화1), 100)
	F같은값_확인(테스트, v통화.S절대값(c통화2), 100)
	
	F같은값_확인(테스트, v통화.S더하기(c통화1, c통화2), 0)
	F같은값_확인(테스트, v통화.S빼기(c통화1, c통화2), 200)
	F같은값_확인(테스트, v통화.S곱하기(c통화1, c통화2), -10000)
	
	v통화, 에러 := v통화.S나누기(c통화1, c통화2)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v통화, -1)
	
	v통화, 에러 = v통화.S나누기(c통화1, NC통화(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v통화 == nil)
	
	v통화, 에러 = v통화.S역수(c통화1)
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v통화, 0.01)
	
	v통화, 에러 = v통화.S역수(big.NewRat(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v통화 == nil)
	
	F같은값_확인(테스트, v통화.S반대부호값(c통화1), -100)
	F같은값_확인(테스트, v통화.S반대부호값(c통화2), 100)
	
	// 셀프 연산함수 테스트
	F같은값_확인(테스트, NV통화(-100).S셀프_절대값(), 100)
	F같은값_확인(테스트, NV통화(100).S셀프_절대값(), 100)
	
	F같은값_확인(테스트, NV통화(100).S셀프_더하기(c통화1), 200)
	F같은값_확인(테스트, NV통화(100).S셀프_빼기(c통화1), 0)
	F같은값_확인(테스트, NV통화(100).S셀프_곱하기(c통화1), 10000)
	
	v통화, 에러 = NV통화(100).S셀프_나누기(NC통화(10))
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v통화, 10)
	
	v통화, 에러 = NV통화(100).S셀프_나누기(NC통화(0))
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v통화 == nil)
	
	v통화, 에러 = NV통화(100).S셀프_역수()
	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, v통화, 0.01)
	
	v통화, 에러 = NV통화(0).S셀프_역수()
	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, v통화 == nil)
	
	F같은값_확인(테스트, NV통화(100).S셀프_반대부호값(), -100)
	F같은값_확인(테스트, NV통화(-100).S셀프_반대부호값(), 100)
}
*/ 
}