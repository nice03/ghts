package lib

import (
	"math"
	"math/big"
	"math/rand"
	"reflect"
	"strconv"
	"strings"
	"testing"
	"time"
)

func testI정수(테스트 *testing.T, 생성자 interface{}) {
	입력값 := int64(100)
	입력값_백업 := int64(100)

	var i정수 I정수
	var i기본_문자열 I기본_문자열
	var i임의값_생성 I임의값_생성

	// 생성자 테스트
	switch 생성자.(type) {
	case func(int64) C정수:
		생성자_ := 생성자.(func(int64) C정수)
		i정수 = 생성자_(입력값)
	case func(int64) V정수:
		생성자_ := 생성자.(func(int64) V정수)
		i정수 = 생성자_(입력값)
	case func(*sC정수64) V정수:
		생성자_ := 생성자.(func(*sC정수64) V정수)
		i정수 = 생성자_(&sC정수64{&s정수64{입력값}})
	case func(*sV정수64) C정수:
		생성자_ := 생성자.(func(*sV정수64) C정수)
		i정수 = 생성자_(&sV정수64{s정수64: &s정수64{입력값}})
	default:
		F문자열_출력("예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
		테스트.Fail()
	}

	i기본_문자열 = i정수.(I기본_문자열)
	i임의값_생성 = i정수.(I임의값_생성)

	// G값() 테스트
	F같은값_확인(테스트, i정수.G값(), 입력값)
	F같은값_확인(테스트, i정수.G정수(), 입력값)
	F같은값_확인(테스트, i정수.G실수(), 입력값)
	F같은값_확인(테스트, i정수.G정밀수(), 입력값)
	F같은값_확인(테스트, i기본_문자열.String(), strconv.FormatInt(입력값, 10))

	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값 + 1

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, i정수.G값(), 입력값)
	F같은값_확인(테스트, i정수.G값(), 입력값_백업)
	F같은값_확인(테스트, i정수.G정수(), 입력값_백업)
	F같은값_확인(테스트, i정수.G실수(), 입력값_백업)
	F같은값_확인(테스트, i정수.G정밀수(), 입력값_백업)
	F같은값_확인(테스트, i기본_문자열.String(), strconv.FormatInt(입력값_백업, 10))

	// 출력값 변경 후 독립성 확인.
	출력값 := i정수.G값()
	출력값_백업 := 출력값
	F같은값_확인(테스트, 출력값, 출력값_백업)

	출력값 = 출력값 + 1
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, i정수.G값(), 출력값)
	F같은값_확인(테스트, i정수.G값(), 출력값_백업)
	F같은값_확인(테스트, i정수.G정수(), 출력값_백업)
	F같은값_확인(테스트, i정수.G실수(), 출력값_백업)
	F같은값_확인(테스트, i정수.G정밀수(), 출력값_백업)
	F같은값_확인(테스트, i기본_문자열.String(), strconv.FormatInt(출력값_백업, 10))

	// Generate() 테스트
	맵 := make(map[int64]bool)
	임의값_생성기 := rand.New(rand.NewSource(time.Now().UnixNano()))

	양수_수량 := 0
	음수_수량 := 0

	for 반복횟수 := 0; 반복횟수 < 100; 반복횟수++ {
		reflect값 := i임의값_생성.Generate(임의값_생성기, 1)
		값 := reflect값.Interface().(I정수).G값()
		맵[값] = true

		if 값 > 0 {
			양수_수량++
		} else if 값 < 0 {
			음수_수량++
		}
	}

	F참인지_확인(테스트, len(맵) > 90)
	F참인지_확인(테스트, 양수_수량 > 35, "양수 %v개, 음수 %v개", 양수_수량, 음수_수량)
	F참인지_확인(테스트, 음수_수량 > 35, "양수 %v개, 음수 %v개", 양수_수량, 음수_수량)

	// 상수형, 변수형 혼용되지 않는 지 확인
	switch i정수.(type) {
	case C정수:
		c := i정수.(C정수)

		_, ok := c.(*sC정수64)
		F참인지_확인(테스트, ok)

		_, ok = c.(I상수형)
		F참인지_확인(테스트, ok)

		_, ok = c.(I변수형)
		F거짓인지_확인(테스트, ok)
	case V정수:
		v := i정수.(V정수)

		_, ok := v.(*sV정수64)
		F참인지_확인(테스트, ok)

		_, ok = v.(I상수형)
		F거짓인지_확인(테스트, ok)

		_, ok = v.(I변수형)
		F참인지_확인(테스트, ok)
	default:
		F문자열_출력("예상치 못한 경우. %v", reflect.TypeOf(i정수))
	}
}

func TestC정수(테스트 *testing.T) {
	testI정수(테스트, NC정수)
	testI정수(테스트, (*sC정수64).G변수형)

	c := NC정수(100)
	v := c.G변수형()
	F같은값_확인(테스트, c, v)
}

func TestV정수(테스트 *testing.T) {
	testI정수(테스트, NV정수)
	testI정수(테스트, (*sV정수64).G상수형)

	v := NV정수(100)
	c := v.G상수형()
	F같은값_확인(테스트, c, v)

	F같은값_확인(테스트, NV정수(100).S값(300), 300)
	F같은값_확인(테스트, NV정수(100).S절대값(), 100)
	F같은값_확인(테스트, NV정수(-100).S절대값(), 100)
	F같은값_확인(테스트, NV정수(100).S더하기(100), 200)
	F같은값_확인(테스트, NV정수(100).S빼기(100), 0)
	F같은값_확인(테스트, NV정수(100).S곱하기(100), 10000)
	F같은값_확인(테스트, NV정수(100).S나누기(100), 1)

	F문자열_출력_일시정지_시작()
	F같은값_확인(테스트, NV정수(100).S나누기(0), nil)
	F문자열_출력_일시정지_종료()
}

func testI부호없는_정수(테스트 *testing.T, 생성자 interface{}) {
	입력값 := uint64(100)
	입력값_백업 := uint64(100)

	var i부호없는_정수 I부호없는_정수
	var i기본_문자열 I기본_문자열
	var i임의값_생성 I임의값_생성

	// 생성자 테스트
	switch 생성자.(type) {
	case func(uint64) C부호없는_정수:
		생성자_ := 생성자.(func(uint64) C부호없는_정수)
		i부호없는_정수 = 생성자_(입력값)
	case func(uint64) V부호없는_정수:
		생성자_ := 생성자.(func(uint64) V부호없는_정수)
		i부호없는_정수 = 생성자_(입력값)
	case func(*sC부호없는_정수64) V부호없는_정수:
		생성자_ := 생성자.(func(*sC부호없는_정수64) V부호없는_정수)
		i부호없는_정수 = 생성자_(&sC부호없는_정수64{&s부호없는_정수64{입력값}})
	case func(*sV부호없는_정수64) C부호없는_정수:
		생성자_ := 생성자.(func(*sV부호없는_정수64) C부호없는_정수)
		i부호없는_정수 = 생성자_(&sV부호없는_정수64{s부호없는_정수64: &s부호없는_정수64{입력값}})
	default:
		F문자열_출력("예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
		테스트.Fail()
	}

	i기본_문자열 = i부호없는_정수.(I기본_문자열)
	i임의값_생성 = i부호없는_정수.(I임의값_생성)

	// G값() 테스트
	F같은값_확인(테스트, i부호없는_정수.G값(), 입력값)
	F같은값_확인(테스트, i부호없는_정수.G정수(), 입력값)
	F같은값_확인(테스트, i부호없는_정수.G실수(), 입력값)
	F같은값_확인(테스트, i부호없는_정수.G정밀수(), 입력값)
	F같은값_확인(테스트, i기본_문자열.String(), strconv.FormatUint(입력값, 10))

	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값 + 1

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, i부호없는_정수.G값(), 입력값)
	F같은값_확인(테스트, i부호없는_정수.G값(), 입력값_백업)
	F같은값_확인(테스트, i부호없는_정수.G정수(), 입력값_백업)
	F같은값_확인(테스트, i부호없는_정수.G실수(), 입력값_백업)
	F같은값_확인(테스트, i부호없는_정수.G정밀수(), 입력값_백업)
	F같은값_확인(테스트, i기본_문자열.String(), strconv.FormatUint(입력값_백업, 10))

	// 출력값 변경 후 독립성 확인.
	출력값 := i부호없는_정수.G값()
	출력값_백업 := 출력값
	F같은값_확인(테스트, 출력값, 출력값_백업)

	출력값 = 출력값 + 1

	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, i부호없는_정수.G값(), 출력값)
	F같은값_확인(테스트, i부호없는_정수.G값(), 출력값_백업)
	F같은값_확인(테스트, i부호없는_정수.G정수(), 출력값_백업)
	F같은값_확인(테스트, i부호없는_정수.G실수(), 출력값_백업)
	F같은값_확인(테스트, i부호없는_정수.G정밀수(), 출력값_백업)
	F같은값_확인(테스트, i기본_문자열.String(), strconv.FormatUint(출력값_백업, 10))

	// Generate() 테스트
	맵 := make(map[uint64]bool)
	임의값_생성기 := rand.New(rand.NewSource(time.Now().UnixNano()))

	for 반복횟수 := 0; 반복횟수 < 100; 반복횟수++ {
		reflect값 := i임의값_생성.Generate(임의값_생성기, 1)
		값 := reflect값.Interface().(I부호없는_정수).G값()
		맵[값] = true
	}

	F참인지_확인(테스트, len(맵) > 90)

	switch i부호없는_정수.(type) {
	case C부호없는_정수:
		c := i부호없는_정수.(C부호없는_정수)

		_, ok := c.(*sC부호없는_정수64)
		F참인지_확인(테스트, ok)

		_, ok = c.(I상수형)
		F참인지_확인(테스트, ok)

		_, ok = c.(I변수형)
		F거짓인지_확인(테스트, ok)
	case V부호없는_정수:
		v := i부호없는_정수.(V부호없는_정수)

		_, ok := v.(*sV부호없는_정수64)
		F참인지_확인(테스트, ok)

		_, ok = v.(I상수형)
		F거짓인지_확인(테스트, ok)

		_, ok = v.(I변수형)
		F참인지_확인(테스트, ok)
	default:
		F문자열_출력("예상치 못한 경우. %v", reflect.TypeOf(i부호없는_정수))
	}
}

func TestC부호없는_정수(테스트 *testing.T) {
	testI부호없는_정수(테스트, NC부호없는_정수)
	testI부호없는_정수(테스트, (*sC부호없는_정수64).G변수형)

	c := NC부호없는_정수(100)
	v := c.G변수형()
	F같은값_확인(테스트, c, v)
}

func TestV부호없는_정수(테스트 *testing.T) {
	testI부호없는_정수(테스트, NV부호없는_정수)
	testI부호없는_정수(테스트, (*sV부호없는_정수64).G상수형)

	v := NV부호없는_정수(100)
	c := v.G상수형()
	F같은값_확인(테스트, c, v)

	F같은값_확인(테스트, NV부호없는_정수(100).S값(300), 300)
	F같은값_확인(테스트, NV부호없는_정수(100).S더하기(100), 200)
	F같은값_확인(테스트, NV부호없는_정수(100).S빼기(100), 0)
	F같은값_확인(테스트, NV부호없는_정수(100).S곱하기(100), 10000)
	F같은값_확인(테스트, NV부호없는_정수(100).S나누기(100), 1)

	F문자열_출력_일시정지_시작()
	F같은값_확인(테스트, NV부호없는_정수(100).S나누기(0), nil)
	F문자열_출력_일시정지_종료()
}

func testI실수(테스트 *testing.T, 생성자 interface{}) {
	입력값 := float64(100.1)
	입력값_백업 := float64(100.1)

	var i실수 I실수
	var i기본_문자열 I기본_문자열
	var i임의값_생성 I임의값_생성

	// 생성자 테스트
	switch 생성자.(type) {
	case func(float64) C실수:
		생성자_ := 생성자.(func(float64) C실수)
		i실수 = 생성자_(입력값)
	case func(float64) V실수:
		생성자_ := 생성자.(func(float64) V실수)
		i실수 = 생성자_(입력값)
	case func(*sC실수64) V실수:
		생성자_ := 생성자.(func(*sC실수64) V실수)
		i실수 = 생성자_(&sC실수64{&s실수64{입력값}})
	case func(*sV실수64) C실수:
		생성자_ := 생성자.(func(*sV실수64) C실수)
		i실수 = 생성자_(&sV실수64{s실수64: &s실수64{입력값}})
	default:
		F문자열_출력("예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
		테스트.Fail()
	}

	i기본_문자열 = i실수.(I기본_문자열)
	i임의값_생성 = i실수.(I임의값_생성)

	// G값() 테스트
	F같은값_확인(테스트, i실수.G값(), 입력값)
	F같은값_확인(테스트, i실수.G실수(), 입력값)
	F같은값_확인(테스트, i실수.G정밀수(), 입력값)
	F같은값_확인(테스트, i기본_문자열.String(), F문자열(입력값))

	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값 + 1

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, i실수.G값(), 입력값)
	F같은값_확인(테스트, i실수.G값(), 입력값_백업)
	F같은값_확인(테스트, i실수.G실수(), 입력값_백업)
	F같은값_확인(테스트, i실수.G정밀수(), 입력값_백업)
	F같은값_확인(테스트, i기본_문자열.String(), F문자열(입력값_백업))

	// 출력값 변경 후 독립성 확인.
	출력값 := i실수.G값()
	출력값_백업 := 출력값
	F같은값_확인(테스트, 출력값, 출력값_백업)

	출력값 = 출력값 + 1.1
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, i실수.G값(), 출력값)
	F같은값_확인(테스트, i실수.G값(), 출력값_백업)
	F같은값_확인(테스트, i실수.G실수(), 출력값_백업)
	F같은값_확인(테스트, i실수.G정밀수(), 출력값_백업)
	F같은값_확인(테스트, i기본_문자열.String(), F문자열(입력값_백업))

	// Generate() 테스트
	맵 := make(map[float64]bool)
	임의값_생성기 := rand.New(rand.NewSource(time.Now().UnixNano()))

	양수_수량 := 0
	음수_수량 := 0

	for 반복횟수 := 0; 반복횟수 < 100; 반복횟수++ {
		reflect값 := i임의값_생성.Generate(임의값_생성기, 1)
		값 := reflect값.Interface().(I실수).G값()
		맵[값] = true

		if 값 > 0 {
			양수_수량++
		} else if 값 < 0 {
			음수_수량++
		}
	}

	F참인지_확인(테스트, len(맵) > 90)
	F참인지_확인(테스트, 양수_수량 > 30, "양수 %v개, 음수 %v개", 양수_수량, 음수_수량)
	F참인지_확인(테스트, 음수_수량 > 30, "양수 %v개, 음수 %v개", 양수_수량, 음수_수량)

	// 상수형, 변수형 혼용되지 않는 지 확인
	switch i실수.(type) {
	case C실수:
		c := i실수.(C실수)

		_, ok := c.(*sC실수64)
		F참인지_확인(테스트, ok)

		_, ok = c.(I상수형)
		F참인지_확인(테스트, ok)

		_, ok = c.(I변수형)
		F거짓인지_확인(테스트, ok)
	case V실수:
		v := i실수.(V실수)

		_, ok := v.(*sV실수64)
		F참인지_확인(테스트, ok)

		_, ok = v.(I상수형)
		F거짓인지_확인(테스트, ok)

		_, ok = v.(I변수형)
		F참인지_확인(테스트, ok)
	default:
		F문자열_출력("예상치 못한 경우. %v", reflect.TypeOf(i실수))
	}
}

func TestC실수(테스트 *testing.T) {
	testI실수(테스트, NC실수)
	testI실수(테스트, (*sC실수64).G변수형)

	c := NC실수(100.1)
	v := c.G변수형()
	F같은값_확인(테스트, c, v)
}

func TestV실수(테스트 *testing.T) {
	testI실수(테스트, NV실수)
	testI실수(테스트, (*sV실수64).G상수형)

	v := NV실수(100.1)
	c := v.G상수형()
	F같은값_확인(테스트, c, v)

	F같은값_확인(테스트, NV실수(100.0).S값(300.0), 300)
	F같은값_확인(테스트, NV실수(100.0).S절대값(), 100)
	F같은값_확인(테스트, NV실수(-100.0).S절대값(), 100)
	F같은값_확인(테스트, NV실수(100.0).S더하기(100.0), 200)
	F같은값_확인(테스트, NV실수(100.0).S빼기(100.0), 0)
	F같은값_확인(테스트, NV실수(100.0).S곱하기(100.0), 10000)
	F같은값_확인(테스트, NV실수(100.0).S나누기(100.0), 1)
	F같은값_확인(테스트, NV실수(100.0).S역수(), 0.01)

	F문자열_출력_일시정지_시작()
	F참인지_확인(테스트, math.IsInf(NV실수(100.0).S나누기(0.0).G값(), 0))
	F참인지_확인(테스트, math.IsInf(NV실수(0.0).S역수().G값(), 0))
	F문자열_출력_일시정지_종료()
}

func testI시점(테스트 *testing.T, 생성자 interface{}) {
	F_TODO("testI시점부터 앞에 코드 참고해서 보완할 것.")

	입력값, _ := F문자열2시점("2000-01-01")
	입력값_백업, _ := F문자열2시점("2000-01-01")
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var 시점 I시점

	// 생성자 테스트
	switch 생성자.(type) {
	case func(time.Time) C시점:
		생성자_ := 생성자.(func(time.Time) C시점)
		시점 = 생성자_(입력값)
	case func(time.Time) V시점:
		생성자_ := 생성자.(func(time.Time) V시점)
		시점 = 생성자_(입력값)
	default:
		panic("testI시점() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 시점.G값(), 입력값)

	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값.AddDate(0, 0, 1)

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 시점.G값(), 입력값)
	F같은값_확인(테스트, 시점.G값(), 입력값_백업)

	// 출력값 변경 후 독립성 확인.
	출력값 := 시점.G값()
	출력값_백업 := F시점_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)

	출력값 = 출력값.AddDate(0, 0, 1)
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 시점.G값())
	F같은값_확인(테스트, 출력값_백업, 시점.G값())
}

func TestC시점(테스트 *testing.T) {
	testI시점(테스트, NC시점)

	일자, _ := F문자열2시점("2000-01-01")
	c시점 := NC시점(일자)

	switch c시점.(type) {
	case I변수형, V시점:
		테스트.Error("common.TestC시점() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV시점(테스트 *testing.T) {
	testI시점(테스트, NV시점)

	입력값, _ := F문자열2시점("2000-01-01")
	입력값_백업, _ := F문자열2시점("2000-01-01")

	var v시점 V시점 = NV시점(입력값)
	var c시점 C시점 = v시점.G상수형()

	// G상수형() 테스트
	F같은값_확인(테스트, c시점.G값(), 입력값_백업)

	// S값() 테스트.
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := F시점_복사(입력값).AddDate(0, 0, 1)

	F다른값_확인(테스트, 입력값, 바뀐값)

	v시점.S값(바뀐값)

	F같은값_확인(테스트, v시점.G값(), 바뀐값)
	F같은값_확인(테스트, c시점.G값(), 입력값)

	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v시점.(type) {
	case I변수형, V시점:
		// OK
	case I상수형, C시점:
		테스트.Error("common.TestV시점() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch v시점.(type) 예상치 못한 경우.")
	}

	switch c시점.(type) {
	case I상수형, C시점:
		// OK
	case I변수형, V시점:
		테스트.Error("common.TestV시점() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch c시점.(type) 예상치 못한 경우.")
	}
}

func testI정밀수(테스트 *testing.T, 생성자 interface{}) {
	입력값 := NC정밀수(10.0045)
	입력값_백업 := NC정밀수(10.0045)

	var 정밀수 I정밀수

	// 생성자 테스트
	switch 생성자.(type) {
	case func(interface{}) C정밀수:
		생성자_ := 생성자.(func(interface{}) C정밀수)
		정밀수 = 생성자_(입력값)
	case func(interface{}) V정밀수:
		생성자_ := 생성자.(func(interface{}) V정밀수)
		정밀수 = 생성자_(입력값)
	case func(*sC정밀수) V정밀수: // sC정밀수.G변수형() 메소드
		생성자_ := 생성자.(func(*sC정밀수) V정밀수)
		bigRat, _ := new(big.Rat).SetString(F문자열(입력값))
		정밀수 = 생성자_(&sC정밀수{&s정밀수{bigRat}})
	case func(*sV정밀수) C정밀수: // sV정밀수.G상수형() 메소드
		생성자_ := 생성자.(func(*sV정밀수) C정밀수)
		bigRat, _ := new(big.Rat).SetString(F문자열(입력값))
		정밀수 = 생성자_(&sV정밀수{s정밀수: &s정밀수{bigRat}})
	default:
		테스트.Errorf("%stestI정밀수() : 알려지지 않은  생성자 타입 %v.",
			F소스코드_위치(2), reflect.TypeOf(생성자))
	}

	// G값() 테스트
	F같은값_확인(테스트, 정밀수, 입력값)

	// G실수값() 테스트
	F같은값_확인(테스트, 정밀수.G실수(), 입력값)

	// G문자열() 및 String() 테스트
	F같은값_확인(테스트, 정밀수.(I기본_문자열).String(), "10.0045")

	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	/* 입력값.S더하기(100)

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 정밀수, 입력값)
	F같은값_확인(테스트, 정밀수, 입력값_백업) */

	// GRat()으로 읽어온 값을 변경한 후에도 독립성이 유지되는 지 확인.
	읽어온_값 := 정밀수.GRat()

	F같은값_확인(테스트, 읽어온_값, 입력값_백업)

	읽어온_값.Add(읽어온_값, big.NewRat(100, 1))

	F다른값_확인(테스트, 읽어온_값, 입력값_백업)
	F다른값_확인(테스트, 읽어온_값, 정밀수)
	F같은값_확인(테스트, 정밀수, 입력값_백업)
}

func TestC정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NC정밀수)

	// G변수형() 테스트
	c정밀수 := NC정밀수(0.0)
	testI정밀수(테스트, (*sC정밀수).G변수형)

	// 상수형은 변수형으로 변환되면 안 된다.
	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NV정밀수)

	var v정밀수 V정밀수 = NV정밀수(100)
	var c정밀수 C정밀수 = v정밀수.G상수형()

	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v정밀수.(type) {
	case I변수형, V정밀수:
		// OK
	case I상수형, C정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 제대로 판정되지 않음. 타입 %v",
			F소스코드_위치(1), F값_확인_문자열(v정밀수))
	}

	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 제대로 판정되지 않을 수 있음.", F소스코드_위치(1))
	}

	// G상수형() 테스트
	testI정밀수(테스트, (*sV정밀수).G상수형)

	// 테스트 준비.
	입력값 := 10.0045
	입력값_백업 := 10.0045

	v정밀수 = NV정밀수(입력값)
	c정밀수 = v정밀수.G상수형()

	// S값() 실행 후 변수형 값은 변경되고, G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	입력값 += 100

	F다른값_확인(테스트, 입력값, 입력값_백업)

	v정밀수.S값(입력값)

	F같은값_확인(테스트, v정밀수, 입력값)    // v정밀수 값은 바뀌어야 함.
	F같은값_확인(테스트, c정밀수, 입력값_백업) // c정밀수 값은 그대로 이어야 함.

	// 연산함수 테스트
	F같은값_확인(테스트, NV정밀수(10.0045).S반올림(2).G실수(), 10.0)
	F같은값_확인(테스트, NV정밀수(10.0045).S반올림(3).G실수(), 10.005)

	F같은값_확인(테스트, NV정밀수(-100).S절대값().G실수(), 100.0)
	F같은값_확인(테스트, NV정밀수(100).S절대값().G실수(), 100.0)

	F같은값_확인(테스트, NV정밀수(100).S더하기(100).G실수(), 200.0)
	F같은값_확인(테스트, NV정밀수(100).S빼기(100).G실수(), 0.0)
	F같은값_확인(테스트, NV정밀수(100).S곱하기(100).G실수(), 10000.0)
	F같은값_확인(테스트, NV정밀수(100).S나누기(10), 10)
	F같은값_확인(테스트, NV정밀수(100).S나누기(0).GRat(), nil)
	F같은값_확인(테스트, NV정밀수(100).S역수(), 0.01)
	F같은값_확인(테스트, NV정밀수(0).S역수().GRat(), nil)
	F같은값_확인(테스트, NV정밀수(100).S반대부호값(), -100)
	F같은값_확인(테스트, NV정밀수(-100).S반대부호값(), 100)
}

func testI통화(테스트 *testing.T, 생성자 interface{}) {
	// 통화종류를 임의로 선택하기.
	통화종류 := F임의_통화종류()
	초기값 := 11111.1111

	var 통화 I통화

	// 생성자 테스트
	switch 생성자.(type) {
	case func(P통화종류, interface{}) C통화:
		생성자_ := 생성자.(func(P통화종류, interface{}) C통화)
		통화 = 생성자_(통화종류, 초기값)
	case func(P통화종류, interface{}) V통화:
		생성자_ := 생성자.(func(P통화종류, interface{}) V통화)
		통화 = 생성자_(통화종류, 초기값)
	case func(interface{}) C통화:
		생성자_ := 생성자.(func(interface{}) C통화)
		통화 = 생성자_(초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(interface{}) V통화:
		생성자_ := 생성자.(func(interface{}) C통화)
		통화 = 생성자_(초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(*sC통화) V통화: // sC통화.G변수형() 메소드
		생성자_ := 생성자.(func(*sC통화) V통화)
		통화 = 생성자_(&sC통화{종류: 통화종류, 금액: NC정밀수(초기값)})
	case func(*sV통화) C통화: // sV통화.G상수형() 메소드
		생성자_ := 생성자.(func(*sV통화) C통화)
		통화 = 생성자_(&sV통화{종류: 통화종류, 금액: NV정밀수(초기값)})
	default:
		테스트.Errorf("%stestI통화() : 알려지지 않은  생성자 타입 %v.",
			F소스코드_위치(2), reflect.TypeOf(생성자))
	}

	입력값 := F반올림(초기값, F통화종류별_정밀도(통화종류)).G변수형()
	입력값_백업 := F반올림(초기값, F통화종류별_정밀도(통화종류)).G변수형()

	// String() 테스트

	문자열 := 통화.(I기본_문자열).String()
	if F통화종류별_정밀도(통화종류) == 0 {
		F같은값_확인(테스트, 문자열, 통화종류.String()+" "+"11,111")
	} else {
		F참인지_확인(테스트,
			strings.HasPrefix(문자열, 통화종류.String()+" "+"11,111."),
			"통화.String() %v", 문자열)
	}

	// 통화 그 자체로 비교되는 지 확인
	F같은값_확인(테스트, 통화, NC통화(통화종류, 입력값.G상수형()))

	// G종류() 테스트
	F같은값_확인(테스트, 통화.G종류(), 통화종류)

	// G값() 테스트
	F같은값_확인(테스트, 통화.G값(), 입력값)

	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	// 입력값 변수를 변경
	입력값.S더하기(100)

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 통화.G값(), 입력값)
	F같은값_확인(테스트, 통화.G값(), 입력값_백업)
}

func TestC통화(테스트 *testing.T) {
	testI통화(테스트, NC통화)
	testI통화(테스트, (*sC통화).G변수형)

	// 상수형은 변수형으로 변환되면 안 된다.
	c통화 := NC통화(KRW, 0.0)

	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV통화(테스트 *testing.T) {
	testI통화(테스트, NV통화)
	testI통화(테스트, (*sV통화).G상수형)

	// 통화종류를 매번 다르게 선택하기.
	통화종류 := F임의_통화종류()

	초기값 := 11111.1111

	입력값 := F반올림(초기값, F통화종류별_정밀도(통화종류)).G변수형()
	입력값_백업 := F반올림(초기값, F통화종류별_정밀도(통화종류)).G변수형()

	v통화 := NV통화(통화종류, 초기값)
	c통화 := v통화.G상수형()

	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v통화.(type) {
	case I변수형, V통화:
		// OK
	case I상수형, C통화:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}

	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}

	// S값() 실행 후 변수형 값은 변경되고,
	// G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	입력값.S더하기(100)

	F다른값_확인(테스트, 입력값, 입력값_백업)

	v통화.S값(입력값.G상수형())

	F같은값_확인(테스트, v통화.G값(), 입력값)
	F같은값_확인(테스트, c통화.G값(), 입력값_백업)

	F같은값_확인(테스트, NV통화(통화종류, -100).S절대값().G값(), 100)
	F같은값_확인(테스트, NV통화(통화종류, 100).S절대값().G값(), 100)
	F같은값_확인(테스트, NV통화(통화종류, 100).S더하기(100).G값(), 200)
	F같은값_확인(테스트, NV통화(통화종류, 100).S빼기(100).G값(), 0)
	F같은값_확인(테스트, NV통화(통화종류, 100).S곱하기(100).G값(), 10000)
	F같은값_확인(테스트, NV통화(통화종류, 100).S나누기(10).G값(), 10)
	F같은값_확인(테스트, NV통화(통화종류, 100).S나누기(0).G값(), nil)
	F같은값_확인(테스트, NV통화(통화종류, 100).S반대부호값().G값(), -100)
	F같은값_확인(테스트, NV통화(통화종류, -100).S반대부호값().G값(), 100)
}

func TestN일자_문자열(테스트 *testing.T) {
	F문자열_출력_일시정지_시작()
	defer F문자열_출력_일시정지_종료()

	c일자 := NC시점_문자열("2000-01-01")
	F같은값_확인(테스트, c일자.G값().Format("2006-01-02"), "2000-01-01")

	c일자 = NC시점_문자열("변환 불가능한 문자열")
	F같은값_확인(테스트, c일자, nil)

	v일자 := NV시점_문자열("2000-01-01")
	F같은값_확인(테스트, v일자.G값().Format("2006-01-02"), "2000-01-01")

	v일자 = NV시점_문자열("변환 불가능한 문자열")
	F같은값_확인(테스트, v일자, nil)
}

func TestN정밀수(테스트 *testing.T) {
	도우미_N정밀수_에러(테스트, nil)

	예상값 := big.NewRat(100, 1)
	도우미_N정밀수(테스트, uint(100), 예상값)
	도우미_N정밀수(테스트, uint8(100), 예상값)
	도우미_N정밀수(테스트, uint16(100), 예상값)
	도우미_N정밀수(테스트, uint32(100), 예상값)
	도우미_N정밀수(테스트, uint64(100), 예상값)
	도우미_N정밀수(테스트, int(100), 예상값)
	도우미_N정밀수(테스트, int8(100), 예상값)
	도우미_N정밀수(테스트, int16(100), 예상값)
	도우미_N정밀수(테스트, int32(100), 예상값)
	도우미_N정밀수(테스트, int64(100), 예상값)

	예상값 = big.NewRat(10002, 100)
	도우미_N정밀수(테스트, float32(100.02), 예상값)
	도우미_N정밀수(테스트, float64(100.02), 예상값)

	예상값 = big.NewRat(100, 1)
	도우미_N정밀수(테스트, NC부호없는_정수(100), 예상값)
	도우미_N정밀수(테스트, NC정수(100), 예상값)

	예상값 = big.NewRat(100025, 1000)
	도우미_N정밀수(테스트, NC실수(100.025), 예상값)
	도우미_N정밀수(테스트, NC정밀수(100.025), 예상값)

	예상값 = big.NewRat(100, 1)
	도우미_N정밀수(테스트, NC통화(KRW, 100.025).G값(), 예상값)

	도우미_N정밀수(테스트, "100", 예상값)

	도우미_N정밀수_에러(테스트, "변환 불가능한 문자열")
}

func 도우미_N정밀수(테스트 *testing.T, 원본값 interface{}, 예상값 *big.Rat) {
	c정밀수 := NC정밀수(원본값)

	F참인지_확인(테스트, c정밀수 != nil)
	F같은값_확인(테스트, c정밀수.GRat(), 예상값)

	v정밀수 := NV정밀수(원본값)

	F참인지_확인(테스트, v정밀수 != nil)
	F같은값_확인(테스트, v정밀수.GRat(), 예상값)
}

func 도우미_N정밀수_에러(테스트 *testing.T, 원본값 interface{}) {
	F문자열_출력_일시정지_시작()
	defer F문자열_출력_일시정지_종료()
	c정밀수 := NC정밀수(원본값)

	F참인지_확인(테스트, c정밀수 == nil)

	v정밀수 := NV정밀수(원본값)

	F참인지_확인(테스트, v정밀수 == nil)
}

func TestI통화G같음(테스트 *testing.T) {
	F참인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, 100.0)))
	F참인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, "100.0")))

	// 통화종류만 바꾸어도 달라야 함.
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(USD, 100.0)))
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(USD, "100.0")))

	// 통화 금액만 바꾸어도 달라야 함.
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, 200.0)))
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, "200.0")))
}

/*
func TestV통화S절대값(테스트 *testing.T) {
	F_TODO("TestF통화_절대값() 이하 통화 관련 연산함수 테스트.")
	입력값 := big.NewRat(-1001, 10)
	출력값 := F통화_절대값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))

	입력값 = big.NewRat(1001, 10)
	출력값 = F통화_절대값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))
}

func TestV통화S더하기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값 := F통화_더하기(입력값1, 입력값2)

	F같은값_확인(테스트, 출력값, big.NewRat(2002, 10))
}

func TestV통화S빼기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값 := F통화_빼기(입력값1, 입력값2)

	F같은값_확인(테스트, 출력값, big.NewRat(0, 1))
}

func TestV통화S곱하기(테스트 *testing.T) {
	입력값1 := big.NewRat(100, 1)
	입력값2 := big.NewRat(100, 1)
	출력값 := F통화_곱하기(입력값1, 입력값2)

	F같은값_확인(테스트, 출력값, big.NewRat(10000, 1))
}

func TestV통화S나누기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값, 에러 := F통화_나누기(입력값1, 입력값2)

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewRat(1, 1))

	// 에러가 발생하는 것을 어떻게 처리해야 하나?
	입력값1 = big.NewRat(1001, 10)
	입력값2 = big.NewRat(0, 1)
	출력값, 에러 = F통화_나누기(입력값1, 입력값2)

	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 출력값 == nil, "")
}

func TestV통화S역수(테스트 *testing.T) {
	입력값 := big.NewRat(1001, 10)
	출력값, 에러 := F통화_역수(입력값)

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewRat(10, 1001))

	입력값 = big.NewRat(0, 1)
	출력값, 에러 = F통화_역수(입력값)

	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 출력값 == nil, "")
}

func TestV통화S반대부호값(테스트 *testing.T) {
	입력값 := big.NewRat(-1001, 10)
	출력값 := F통화_반대부호값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))

	입력값 = big.NewRat(1001, 10)
	출력값 = F통화_반대부호값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(-1001, 10))
} */
