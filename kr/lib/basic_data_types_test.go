package common

import (
	"math/big"
	"reflect"
	"testing"
	"time"
)

func TestC정수(테스트 *testing.T) {
	초기값 := int64(10)
	예상값 := int64(10)

	// 생성자 테스트
	var c정수 C정수 = NC정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10
	F같은값_확인(테스트, c정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	정수값 := c정수.G값()
	정수값 = 정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c정수.G값(), 예상값)

	switch c정수.(type) {
	case I변수형:
		테스트.Error("common.TestC정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC부호없는_정수(테스트 *testing.T) {
	초기값 := uint64(10)
	예상값 := uint64(10)

	// 생성자 테스트
	var c부호없는_정수 C부호없는_정수 = NC부호없는_정수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	부호없는_정수값 := c부호없는_정수.G값()
	부호없는_정수값 = 부호없는_정수값 + 10 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c부호없는_정수.G값(), 예상값)

	switch c부호없는_정수.(type) {
	case I변수형:
		테스트.Error("common.TestC부호없는_정수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC실수(테스트 *testing.T) {
	초기값 := float64(10.0)
	예상값 := float64(10.0)

	// 생성자 테스트
	var c실수 C실수 = NC실수(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c실수.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + 10

	F같은값_확인(테스트, c실수.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	실수값 := c실수.G값()
	실수값 = 실수값 + 10.0 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c실수.G값(), 예상값)

	switch c실수.(type) {
	case I변수형:
		테스트.Error("common.TestC실수() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC문자열(테스트 *testing.T) {
	초기값 := "테스트 문자열"
	예상값 := "테스트 문자열"

	// 생성자 테스트
	var c문자열 C문자열 = NC문자열(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = 초기값 + "추가 문자열"

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	문자열값 := c문자열.G값()
	문자열값 = 문자열값 + "추가 문자열" // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c문자열.G값(), 예상값)

	switch c문자열.(type) {
	case I변수형:
		테스트.Error("common.TestC문자열() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestC참거짓(테스트 *testing.T) {
	초기값 := true
	예상값 := true

	// 생성자 테스트
	var c참거짓 C참거짓 = NC참거짓(초기값)

	// G값() 테스트
	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// 초기값 변경 후 독립성이 유지되는 지 확인.
	초기값 = !초기값

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	// G값() 결과물 변경 후 독립성이 유지되는 지 확인.
	참거짓값 := c참거짓.G값()
	참거짓값 = !참거짓값 // G값()으로 읽어온 변수를 변경.

	F같은값_확인(테스트, c참거짓.G값(), 예상값)

	switch c참거짓.(type) {
	case I변수형:
		테스트.Error("common.TestC참거짓() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func testI시점(테스트 *testing.T, 생성자 interface{}) {
	입력값, _ := F문자열2시점("2000-01-01")
	입력값_백업, _ := F문자열2시점("2000-01-01")
	F같은값_확인(테스트, 입력값, 입력값_백업)

	var 시점 I시점

	// 생성자 테스트
	switch 생성자.(type) {
	case func(time.Time) C시점:
		생성자_ := 생성자.(func(time.Time) C시점)
		시점 = 생성자_(입력값)
	case func(time.Time) V시점:
		생성자_ := 생성자.(func(time.Time) V시점)
		시점 = 생성자_(입력값)
	default:
		panic("testI시점() : 예상치 못한 생성자 형식. " + reflect.TypeOf(생성자).String())
	}

	// G값() 테스트
	F같은값_확인(테스트, 시점.G값(), 입력값)

	// 입력값 변경 후 독립성 확인.
	입력값 = 입력값.AddDate(0, 0, 1)

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 시점.G값(), 입력값)
	F같은값_확인(테스트, 시점.G값(), 입력값_백업)

	// 출력값 변경 후 독립성 확인.
	출력값 := 시점.G값()
	출력값_백업 := F시점_복사(출력값)
	F같은값_확인(테스트, 출력값, 출력값_백업)

	출력값 = 출력값.AddDate(0, 0, 1)
	F다른값_확인(테스트, 출력값, 출력값_백업)
	F다른값_확인(테스트, 출력값, 시점.G값())
	F같은값_확인(테스트, 출력값_백업, 시점.G값())
}

func TestC시점(테스트 *testing.T) {
	testI시점(테스트, NC시점)

	일자, _ := F문자열2시점("2000-01-01")
	c시점 := NC시점(일자)

	switch c시점.(type) {
	case I변수형, V시점:
		테스트.Error("common.TestC시점() : 상수형이 변수형과 혼동될 수 있음.")
	}
}

func TestV시점(테스트 *testing.T) {
	testI시점(테스트, NV시점)

	입력값, _ := F문자열2시점("2000-01-01")
	입력값_백업, _ := F문자열2시점("2000-01-01")

	var v시점 V시점 = NV시점(입력값)
	var c시점 C시점 = v시점.G상수형()

	// G상수형() 테스트
	F같은값_확인(테스트, c시점.G값(), 입력값_백업)

	// S값() 테스트.
	// 변수형 값은 변경되고, G상수형()의 결과물은 독립성을 유지하는 지 확인.
	바뀐값 := F시점_복사(입력값).AddDate(0, 0, 1)

	F다른값_확인(테스트, 입력값, 바뀐값)

	v시점.S값(바뀐값)

	F같은값_확인(테스트, v시점.G값(), 바뀐값)
	F같은값_확인(테스트, c시점.G값(), 입력값)

	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v시점.(type) {
	case I변수형, V시점:
		// OK
	case I상수형, C시점:
		테스트.Error("common.TestV시점() : 변수형이 상수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch v시점.(type) 예상치 못한 경우.")
	}

	switch c시점.(type) {
	case I상수형, C시점:
		// OK
	case I변수형, V시점:
		테스트.Error("common.TestV시점() : 상수형이 변수형과 혼동될 수 있음.")
	default:
		테스트.Error("common.TestV시점() : switch c시점.(type) 예상치 못한 경우.")
	}
}

func testI정밀수(테스트 *testing.T, 생성자 interface{}) {
	입력값 := big.NewRat(100045, 10000)
	입력값_백업 := new(big.Rat).Set(입력값)

	var 정밀수 I정밀수

	// 생성자 테스트
	switch 생성자.(type) {
	case func(interface{}) C정밀수:
		생성자_ := 생성자.(func(interface{}) C정밀수)
		정밀수 = 생성자_(입력값)
	case func(interface{}) V정밀수:
		생성자_ := 생성자.(func(interface{}) V정밀수)
		정밀수 = 생성자_(입력값)
	case func(*sC정밀수) V정밀수: // sC정밀수.G변수형() 메소드
		생성자_ := 생성자.(func(*sC정밀수) V정밀수)
		정밀수 = 생성자_(&sC정밀수{&s정밀수{입력값}})
	case func(*sV정밀수) C정밀수: // sV정밀수.G상수형() 메소드
		생성자_ := 생성자.(func(*sV정밀수) C정밀수)
		정밀수 = 생성자_(&sV정밀수{s정밀수: &s정밀수{입력값}})
	default:
		테스트.Errorf("%stestI정밀수() : 알려지지 않은  생성자 타입 %v.",
			F소스코드_위치(2),
			reflect.TypeOf(생성자))
	}

	//F값_확인(reflect.TypeOf(생성자))

	// G값() 테스트
	F같은값_확인(테스트, 정밀수, 입력값)

	// G실수값() 테스트
	F같은값_확인(테스트, 정밀수.G실수(), 입력값)

	// G문자열() 및 String() 테스트
	F같은값_확인(테스트, 정밀수.(I기본_문자열).String(), "10.0045")

	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	입력값.Add(입력값, big.NewRat(100, 1)) // 입력값 변수를 변경

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 정밀수, 입력값)
	F같은값_확인(테스트, 정밀수, 입력값_백업)

	// GRat()으로 읽어온 값을 변경한 후에도 독립성이 유지되는 지 확인.
	읽어온_값 := 정밀수.GRat()

	F같은값_확인(테스트, 읽어온_값, 입력값_백업)

	읽어온_값.Add(읽어온_값, big.NewRat(100, 1))

	F다른값_확인(테스트, 읽어온_값, 입력값_백업)
	F다른값_확인(테스트, 읽어온_값, 정밀수)
	F같은값_확인(테스트, 정밀수, 입력값_백업)
}

func TestC정밀수(테스트 *testing.T) {
	testI정밀수(테스트, NC정밀수)

	// G변수형() 테스트
	c정밀수 := NC정밀수(0.0)
	testI정밀수(테스트, (*sC정밀수).G변수형)

	// 상수형은 변수형으로 변환되면 안 된다.
	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC정밀수() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV정밀수(테스트 *testing.T) {
	F테스트_모드_시작()
	defer F테스트_모드_종료()

	testI정밀수(테스트, NV정밀수)

	var v정밀수 V정밀수 = NV정밀수(100)
	var c정밀수 C정밀수 = v정밀수.G상수형()

	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v정밀수.(type) {
	case I변수형, V정밀수:
		// OK
	case I상수형, C정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 변수형이 제대로 판정되지 않음. 타입 %v",
			F소스코드_위치(1), reflect.TypeOf(v정밀수))
	}

	switch c정밀수.(type) {
	case I상수형, C정밀수:
		// OK
	case I변수형, V정밀수:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV정밀수() : 상수형이 제대로 판정되지 않을 수 있음.", F소스코드_위치(1))
	}

	// G상수형() 테스트
	testI정밀수(테스트, (*sV정밀수).G상수형)

	// 테스트 준비.
	입력값 := big.NewRat(100045, 10000)
	입력값_백업 := big.NewRat(100045, 10000)

	v정밀수 = NV정밀수(입력값)
	c정밀수 = v정밀수.G상수형()

	// S값() 실행 후 변수형 값은 변경되고, G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	입력값.Add(입력값, big.NewRat(100, 1))

	F다른값_확인(테스트, 입력값, 입력값_백업)

	v정밀수.S값(입력값)

	F같은값_확인(테스트, v정밀수, 입력값)    // v정밀수 값은 바뀌어야 함.
	F같은값_확인(테스트, c정밀수, 입력값_백업) // c정밀수 값은 그대로 이어야 함.

	// 연산함수 테스트
	F같은값_확인(테스트, NV정밀수(10.0045).S반올림(2).G실수(), 10.0)
	F같은값_확인(테스트, NV정밀수(10.0045).S반올림(3).G실수(), 10.005)

	F같은값_확인(테스트, NV정밀수(-100).S절대값().G실수(), 100.0)
	F같은값_확인(테스트, NV정밀수(100).S절대값().G실수(), 100.0)

	F같은값_확인(테스트, NV정밀수(100).S더하기(100).G실수(), 200.0)
	F같은값_확인(테스트, NV정밀수(100).S빼기(100).G실수(), 0.0)
	F같은값_확인(테스트, NV정밀수(100).S곱하기(100).G실수(), 10000.0)

	v정밀수 = NV정밀수(100).S나누기(10)
	F같은값_확인(테스트, v정밀수, 10)

	v정밀수 = NV정밀수(100).S나누기(0)
	F참인지_확인(테스트, v정밀수 == nil)

	v정밀수 = NV정밀수(100).S역수()
	F같은값_확인(테스트, v정밀수, 0.01)

	v정밀수 = NV정밀수(0).S역수()
	F참인지_확인(테스트, v정밀수 == nil)

	F같은값_확인(테스트, NV정밀수(100).S반대부호값(), -100)
	F같은값_확인(테스트, NV정밀수(-100).S반대부호값(), 100)

	// 연산 함수 테스트.
	c정밀수1 := NC정밀수(100.0)
	c정밀수2 := NC정밀수(-100.0)

	v정밀수 = NV정밀수(0)
	F같은값_확인(테스트, v정밀수.S절대값2(c정밀수1), 100)
	F같은값_확인(테스트, v정밀수.S절대값2(c정밀수2), 100)

	F같은값_확인(테스트, v정밀수.S더하기2(c정밀수1, c정밀수2), 0)
	F같은값_확인(테스트, v정밀수.S빼기2(c정밀수1, c정밀수2), 200)
	F같은값_확인(테스트, v정밀수.S곱하기2(c정밀수1, c정밀수2), -10000)

	v정밀수 = v정밀수.S나누기2(c정밀수1, c정밀수2)
	F같은값_확인(테스트, v정밀수, -1)

	v정밀수 = v정밀수.S나누기2(c정밀수1, 0)
	F참인지_확인(테스트, v정밀수 == nil)

	v정밀수 = NV정밀수(0)
	v정밀수 = v정밀수.S역수2(c정밀수1)
	F같은값_확인(테스트, v정밀수, 0.01)

	v정밀수 = v정밀수.S역수2(0)
	F참인지_확인(테스트, v정밀수 == nil)

	v정밀수 = NV정밀수(0)
	F같은값_확인(테스트, v정밀수.S반대부호값2(c정밀수1), -100)
	F같은값_확인(테스트, v정밀수.S반대부호값2(c정밀수2), 100)
}

func testI통화(테스트 *testing.T, 생성자 interface{}) {
	// 통화종류를 임의로 선택하기.
	통화종류 := F임의_통화종류()
	초기값 := 11111.1111

	var 통화 I통화

	// 생성자 테스트
	switch 생성자.(type) {
	case func(P통화, interface{}) C통화:
		생성자_ := 생성자.(func(P통화, interface{}) C통화)
		통화 = 생성자_(통화종류, 초기값)
	case func(P통화, interface{}) V통화:
		생성자_ := 생성자.(func(P통화, interface{}) V통화)
		통화 = 생성자_(통화종류, 초기값)
	case func(interface{}) C통화:
		생성자_ := 생성자.(func(interface{}) C통화)
		통화 = 생성자_(초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(interface{}) V통화:
		생성자_ := 생성자.(func(interface{}) C통화)
		통화 = 생성자_(초기값)
		if 통화.G종류() != 통화종류 {
			통화종류 = 통화.G종류()
		}
	case func(*sC통화) V통화: // sC통화.G변수형() 메소드
		생성자_ := 생성자.(func(*sC통화) V통화)
		통화 = 생성자_(&sC통화{종류: 통화종류, 금액: NC정밀수(초기값)})
	case func(*sV통화) C통화: // sV통화.G상수형() 메소드
		생성자_ := 생성자.(func(*sV통화) C통화)
		통화 = 생성자_(&sV통화{종류: 통화종류, 금액: NV정밀수(초기값)})
	default:
		테스트.Errorf("%stestI통화() : 알려지지 않은  생성자 타입 %v.",
			F소스코드_위치(2),
			reflect.TypeOf(생성자))
	}

	입력값 := F반올림(초기값, F통화종류별_정밀도(통화종류)).GRat()
	입력값_백업 := F반올림(초기값, F통화종류별_정밀도(통화종류)).GRat()

	// String() 테스트
	F_TODO("통화.String() 구현 후 테스트 활성화.")
	/*
		문자열 := 통화.(I기본_문자열).String()
		if F통화종류별_정밀도(통화종류) == 0 {
			F같은값_확인(테스트, 문자열, string(통화종류)+" "+"11,111")
		} else {
			F참인지_확인(테스트, strings.HasPrefix(문자열,
				string(통화종류)+" "+"11,111."),
				"통화.String() %v", 문자열)
		} */

	// 통화 그 자체로 비교되는 지 확인
	F같은값_확인(테스트, 통화, NC통화(통화종류, 입력값))

	// G종류() 테스트
	F같은값_확인(테스트, 통화.G종류(), 통화종류)

	// G값() 테스트
	F같은값_확인(테스트, 통화.G값(), 입력값)

	// 입력값 변수를 변경한 후에도 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	// 입력값 변수를 변경
	입력값.Add(입력값, big.NewRat(100, 1))

	F다른값_확인(테스트, 입력값, 입력값_백업)
	F다른값_확인(테스트, 통화.G값(), 입력값)
	F같은값_확인(테스트, 통화.G값(), 입력값_백업)
}

func TestC통화(테스트 *testing.T) {
	testI통화(테스트, NC통화)
	testI통화(테스트, (*sC통화).G변수형)

	// 상수형은 변수형으로 변환되면 안 된다.
	c통화 := NC통화(KRW, 0.0)

	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestC통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}
}

func TestV통화(테스트 *testing.T) {
	F테스트_모드_시작()
	defer F테스트_모드_종료()

	testI통화(테스트, NV통화)
	testI통화(테스트, (*sV통화).G상수형)

	// 통화종류를 매번 다르게 선택하기.
	통화종류 := F임의_통화종류()

	초기값 := 11111.1111

	입력값 := F반올림(초기값, F통화종류별_정밀도(통화종류)).GRat()
	입력값_백업 := F반올림(초기값, F통화종류별_정밀도(통화종류)).GRat()

	v통화 := NV통화(통화종류, 초기값)
	c통화 := v통화.G상수형()

	// 변수형은 상수형은 서로 변환되면 안 된다.
	// 그렇게 되면 변수형도 상수형으로 통용되고, 상수형의 변경불가 속성이 보장되지 않는다.
	switch v통화.(type) {
	case I변수형, V통화:
		// OK
	case I상수형, C통화:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 상수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 변수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}

	switch c통화.(type) {
	case I상수형, C통화:
		// OK
	case I변수형, V통화:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 변수형과 혼동됨.", F소스코드_위치(1))
	default:
		테스트.Errorf("%scommon.TestV통화() : 상수형이 제대로 판정되지 않음.", F소스코드_위치(1))
	}

	// S값() 실행 후 변수형 값은 변경되고,
	// G상수형()의 결과물은 변하지 않고 독립성을 유지하는 지 확인.
	F같은값_확인(테스트, 입력값, 입력값_백업)

	입력값.Add(입력값, big.NewRat(100, 1))

	F다른값_확인(테스트, 입력값, 입력값_백업)

	v통화.S값(입력값)

	F같은값_확인(테스트, v통화.G값(), 입력값)
	F같은값_확인(테스트, c통화.G값(), 입력값_백업)

	F같은값_확인(테스트, NV통화(통화종류, -100).S절대값().G값(), 100)
	F같은값_확인(테스트, NV통화(통화종류, 100).S절대값().G값(), 100)
	F같은값_확인(테스트, NV통화(통화종류, 100).S더하기(100).G값(), 200)
	F같은값_확인(테스트, NV통화(통화종류, 100).S빼기(100).G값(), 0)
	F같은값_확인(테스트, NV통화(통화종류, 100).S곱하기(100).G값(), 10000)
	F같은값_확인(테스트, NV통화(통화종류, 100).S나누기(10).G값(), 10)
	F참인지_확인(테스트, NV통화(통화종류, 100).S나누기(0) == nil)

	v통화 = NV통화(통화종류, 0)
	F같은값_확인(테스트, NV통화(통화종류, 100).S반대부호값().G값(), -100)
	F같은값_확인(테스트, NV통화(통화종류, -100).S반대부호값().G값(), 100)

	// 연산 함수 테스트.
	c통화1 := NC통화(통화종류, 100.0)
	c통화2 := NC통화(통화종류, -100.0)

	F같은값_확인(테스트, v통화.S절대값2(c통화1), NC통화(통화종류, 100))
	F같은값_확인(테스트, v통화.S절대값2(c통화2), NC통화(통화종류, 100))

	F같은값_확인(테스트, v통화.S더하기2(c통화1, c통화2), NC통화(통화종류, 0))
	F같은값_확인(테스트, v통화.S빼기2(c통화1, c통화2), NC통화(통화종류, 200))
	F같은값_확인(테스트, v통화.S곱하기2(c통화1, c통화2), NC통화(통화종류, -10000))
	F같은값_확인(테스트, v통화.S나누기2(c통화1, c통화2), NC통화(통화종류, -1))
	F참인지_확인(테스트, v통화.S나누기2(c통화1, 0) == nil)

	v통화 = NV통화(통화종류, 0)
	F같은값_확인(테스트, v통화.S반대부호값2(c통화1).G값(), -100)
	F같은값_확인(테스트, v통화.S반대부호값2(c통화2).G값(), 100)
}

func TestN일자_문자열(테스트 *testing.T) {
	c일자 := NC시점_문자열("2000-01-01")
	F같은값_확인(테스트, c일자.G값().Format("2006-01-02"), "2000-01-01")

	c일자 = NC시점_문자열("변환 불가능한 문자열")
	F같은값_확인(테스트, c일자, nil)

	v일자 := NV시점_문자열("2000-01-01")
	F같은값_확인(테스트, v일자.G값().Format("2006-01-02"), "2000-01-01")

	v일자 = NV시점_문자열("변환 불가능한 문자열")
	F같은값_확인(테스트, v일자, nil)
}

func TestN정밀수(테스트 *testing.T) {
	도우미_N정밀수_에러(테스트, nil)

	예상값 := big.NewRat(100, 1)
	도우미_N정밀수(테스트, uint(100), 예상값)
	도우미_N정밀수(테스트, uint8(100), 예상값)
	도우미_N정밀수(테스트, uint16(100), 예상값)
	도우미_N정밀수(테스트, uint32(100), 예상값)
	도우미_N정밀수(테스트, uint64(100), 예상값)
	도우미_N정밀수(테스트, int(100), 예상값)
	도우미_N정밀수(테스트, int8(100), 예상값)
	도우미_N정밀수(테스트, int16(100), 예상값)
	도우미_N정밀수(테스트, int32(100), 예상값)
	도우미_N정밀수(테스트, int64(100), 예상값)

	예상값 = big.NewRat(10002, 100)
	도우미_N정밀수(테스트, float32(100.02), 예상값)
	도우미_N정밀수(테스트, float64(100.02), 예상값)

	예상값 = big.NewRat(10025, 100)
	정밀수_참조형 := big.NewRat(100250, 1000)
	도우미_N정밀수(테스트, 정밀수_참조형, 예상값)
	도우미_N정밀수(테스트, *정밀수_참조형, 예상값)

	예상값 = big.NewRat(100, 1)
	도우미_N정밀수(테스트, NC부호없는_정수(100), 예상값)
	도우미_N정밀수(테스트, NC정수(100), 예상값)

	예상값 = big.NewRat(100025, 1000)
	도우미_N정밀수(테스트, NC실수(100.025), 예상값)
	도우미_N정밀수(테스트, NC정밀수(100.025), 예상값)

	예상값 = big.NewRat(100, 1)
	도우미_N정밀수(테스트, NC통화(KRW, 100.025), 예상값)

	도우미_N정밀수(테스트, "100", 예상값)
	도우미_N정밀수(테스트, NC문자열("100"), 예상값)

	도우미_N정밀수_에러(테스트, "변환 불가능한 문자열")
	도우미_N정밀수_에러(테스트, NC문자열("변환 불가능한 문자열"))
}

func 도우미_N정밀수(테스트 *testing.T, 원본값 interface{}, 예상값 *big.Rat) {
	c정밀수 := NC정밀수(원본값)

	F참인지_확인(테스트, c정밀수 != nil)
	F같은값_확인(테스트, c정밀수.GRat(), 예상값)

	v정밀수 := NV정밀수(원본값)

	F참인지_확인(테스트, v정밀수 != nil)
	F같은값_확인(테스트, v정밀수.GRat(), 예상값)
}

func 도우미_N정밀수_에러(테스트 *testing.T, 원본값 interface{}) {
	c정밀수 := NC정밀수(원본값)

	F참인지_확인(테스트, c정밀수 == nil)

	v정밀수 := NV정밀수(원본값)

	F참인지_확인(테스트, v정밀수 == nil)
}

func TestI통화G같음(테스트 *testing.T) {
	F참인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, 100.0)))
	F참인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, "100.0")))

	// 통화종류만 바꾸어도 달라야 함.
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(USD, 100.0)))
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(USD, "100.0")))

	// 통화 금액만 바꾸어도 달라야 함.
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, 200.0)))
	F거짓인지_확인(테스트, NC통화(KRW, 100).G같음(NC통화(KRW, "200.0")))
}

func TestV통화S절대값(테스트 *testing.T) {
	F_TODO("TestF통화_절대값() 이하 통화 관련 연산함수 테스트.")
	입력값 := big.NewRat(-1001, 10)
	출력값 := F통화_절대값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))

	입력값 = big.NewRat(1001, 10)
	출력값 = F통화_절대값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))
}

func TestV통화S더하기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값 := F통화_더하기(입력값1, 입력값2)

	F같은값_확인(테스트, 출력값, big.NewRat(2002, 10))
}

func TestV통화S빼기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값 := F통화_빼기(입력값1, 입력값2)

	F같은값_확인(테스트, 출력값, big.NewRat(0, 1))
}

func TestV통화S곱하기(테스트 *testing.T) {
	입력값1 := big.NewRat(100, 1)
	입력값2 := big.NewRat(100, 1)
	출력값 := F통화_곱하기(입력값1, 입력값2)

	F같은값_확인(테스트, 출력값, big.NewRat(10000, 1))
}

func TestV통화S나누기(테스트 *testing.T) {
	입력값1 := big.NewRat(1001, 10)
	입력값2 := big.NewRat(1001, 10)
	출력값, 에러 := F통화_나누기(입력값1, 입력값2)

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewRat(1, 1))

	// 에러가 발생하는 것을 어떻게 처리해야 하나?
	입력값1 = big.NewRat(1001, 10)
	입력값2 = big.NewRat(0, 1)
	출력값, 에러 = F통화_나누기(입력값1, 입력값2)

	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 출력값 == nil, "")
}

func TestV통화S역수(테스트 *testing.T) {
	입력값 := big.NewRat(1001, 10)
	출력값, 에러 := F통화_역수(입력값)

	F에러없음_확인(테스트, 에러)
	F같은값_확인(테스트, 출력값, big.NewRat(10, 1001))

	입력값 = big.NewRat(0, 1)
	출력값, 에러 = F통화_역수(입력값)

	F에러발생_확인(테스트, 에러)
	F참인지_확인(테스트, 출력값 == nil, "")
}

func TestV통화S반대부호값(테스트 *testing.T) {
	입력값 := big.NewRat(-1001, 10)
	출력값 := F통화_반대부호값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(1001, 10))

	입력값 = big.NewRat(1001, 10)
	출력값 = F통화_반대부호값(입력값)

	F같은값_확인(테스트, 출력값, big.NewRat(-1001, 10))
}